########################################################################
# auto.def - Configure file for the PiDP-8/I software build system,
#            based on autosetup.
########################################################################

define defaultprefix /opt/pidp8i

use cc
use cc-lib

options {
	debug-mode => "create a debug build (default is release)"
	serial-mod => "build simulator to expect the PCB serial mods"
	throttle:  => "override the throttle values in the boot scripts"
}

if {[opt-bool serial-mod]} {
	msg-result "The simulator will expect the serial mods to the Pi and PiDP-8/I PCBs."
	define SERIALSETUP
}

if {[opt-bool debug-mode]} {
	msg-result "Creating a debuggable build."
	define BUILDMODE {-O0 -g}
} else {
	msg-result "Creating a release build."
	define BUILDMODE {-O2}
}

# Translate --throttle value to a SIMH command
set cores [exec tools/corecount]
set tv [opt-val throttle]
set tvsl [string length $tv]
if {($tvsl == 0 && $cores > 1) || $tv == "none"} {
	define SET_THROTTLE {set nothrottle}
	set tv "unlimited"
} else {
	# Rewrite symbolic values with values SIMH can understand.  See
	# README-throttle.md for the justification of these values.
	if {$tv == "single-core" || $tvsl == 0} {
		# value for ~50% CPU usage of a Pi Model B+; also conveniently
		# 5x the speed of a real PDP-8/I
		set tv "1600k"
	} elseif {$tv == "pdp8e"} {
		set tv "416k"
	} elseif {$tv == "pdp8i" || $tv == "pdp8a"} {
		set tv "333k"
	} elseif {$tv == "pdp8l" || $tv == "pdp8"} {
		set tv "313k"
	} elseif {$tv == "ha6120"} {
		set tv "182k"
	} elseif {$tv == "im6100a"} {
		set tv "200k"
	} elseif {$tv == "im6100"} {
		set tv "100k"
	} elseif {$tv == "im6100c"} {
		set tv "83k"
	} elseif {$tv == "pdp8s"} {
		set tv "63k"
	} elseif {$tv == "human"} {
		set tv "10/1000"
	} elseif {$tv == "trace"} {
		set tv "1/1000"
	}
	# else, assume --throttle was given a legal SIMH throttle value

	define SET_THROTTLE "set throttle $tv"
}
msg-result "Simulator CPU throttle set to $tv IPS"

# Compiler and header checks
cc-check-includes time.h
cc-check-functions clock_nanosleep nanosleep usleep

# We need to find an install(1) type program that supports -D.  The
# Raspberry Pi OSes typically used with the PiDB-8/I board do have this,
# but this package also runs on non-Linux OSes (e.g. for testing on a
# desktop Mac) so make sure we've got a suitable implementation.  The
# ginstall name is typical on non-Linux systems where GNU Coreutils was
# installed alongside the core OS utilities.
if {[cc-check-progs ginstall]} {
	define INSTALL ginstall
} elseif {[cc-check-progs install]} {
	if {[catch {exec install -D -d . >& /dev/null} result] == 0} {
		define INSTALL install
	} else {
		user-error "install(1) does not support -D; install GNU Coreutils."
	}
} else {
	user-error "No install(1) type program found; install GNU Coreutils."
}
msg-result "Found GNU install(1) program as [get-define INSTALL]."

# Also find GNU readlink in the same way
if {[cc-check-progs greadlink]} {
	set rlprg greadlink
} elseif {[cc-check-progs readlink]} {
	if {[catch {exec readlink -f . >& /dev/null} result] == 0} {
		set rlprg readlink
	} else {
		user-error "readlink(1) does not support -D; install GNU Coreutils."
	}
} else {
	user-error "No readlink(1) type program found; install GNU Coreutils."
}
msg-result "Found GNU readlink(1) as $rlprg."

# Canonicalize some paths which may be relative and generate others from them
define ABSPREFIX [exec $rlprg -f [get-define prefix]]
define BOOTDIR  "[get-define ABSPREFIX]/share/boot"
define MEDIADIR "[get-define ABSPREFIX]/share/media"

# Remember the name and primary group of the user who installed this, since
# we want to give that group write privileges to some files when they're
# installed, and we want them to own the screen(1) session.
set instgrp [exec id -grn]
set instusr [exec id -urn]
define INSTGRP $instgrp
define INSTUSR $instusr
msg-result "Install group for user-writeable files will be $instgrp."
msg-result "Owner of screen(1) session will be $instusr."

# Can we use any nonstandard flags here?  We don't bother including
# flags that both GCC and Clang support.  The ones inside the "if"
# block are those that Clang will accept in an autosetup test but
# then will yell about if you try to use them.  The test checks for
# an -f sub-option that Clang doesn't currently support even enough
# to fool autosetup.
cc-check-standards c99
cc-check-flags -fipa-cp-clone
cc-check-flags -fno-strict-overflow
cc-check-flags -fpredictive-commoning
if ([get-define HAVE_CFLAG_FIPA_CP_CLONE]) {
	cc-check-flags -fgcse-after-reload
	cc-check-flags -finline-functions
	cc-check-flags -fno-unsafe-loop-optimizations
	define-append CFLAGS "-D_GNU_SOURCE"
}

# Write outputs
make-config-header src/config.h \
	-auto {ENABLE_* HAVE_* PACKAGE_* SIZEOF_*} \
	-bare {SERIALSETUP}
make-template Makefile.in
make-template bin/pidp8i.in
make-template boot/0.script.in
make-template boot/2.script.in
make-template boot/3.script.in
make-template boot/4.script.in
make-template boot/6.script.in
make-template boot/7.script.in
make-template etc/pidp8i-init.in
make-template etc/sudoers.in
make-template src/PDP8/pdp8_cpu.c.in
make-template src/scp.c.in
make-template tools/simh-update.in
exec chmod +x "[get-define builddir]/tools/simh-update"
