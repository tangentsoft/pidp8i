########################################################################
# auto.def - Configure file for the PiDP-8/I software build system,
#            based on autosetup.
#
# Copyright Â© 2016-2017 Warren Young
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS LISTED ABOVE BE LIABLE FOR ANY CLAIM,
# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
# OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
# OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# Except as contained in this notice, the names of the authors above
# shall not be used in advertising or otherwise to promote the sale,
# use or other dealings in this Software without prior written
# authorization from those authors.
########################################################################

define defaultprefix /opt/pidp8i

use cc
use cc-lib
use cc-shared

# Canonicalize some paths which may be relative and generate others from them
set abspfx [file-normalize [get-define prefix]]
define ABSPREFIX $abspfx
define BOOTDIR  "$abspfx/share/boot"
define MEDIADIR "$abspfx/share/media"

# Define options the configure script shares with mkos8.  We insert a
# variant of each into the autosetup option list and also write a
# version to a Python library file that mkos8 can read.  This avoids
# the need to define the options by hand in both places.
#
# Some of the --*-os8-* options are defined only for the configure
# script because they are either meta-options, affecting the definition
# of some of those we do define here, or they aren't passed as-is to the
# mkos8 script, but instead must be translated.  (e.g. --disable-os8-src
# suppresses the call to "mkos8 src" from the Makefile.)
set os8opts {
    advent      1  "Adventure"
    ba          1  "*.BA BASIC games and demos"
    cc8         1  "the native OS/8 CC8 compiler"
    chess       1  "the CHECKMO-II game of chess"
    crt         1  "CRT-style rubout processing"
    dcp         1  "the DCP disassembler"
    focal69     0  "FOCAL 69"
    fortran-ii  1  "FORTRAN II"
    fortran-iv  1  "FORTRAN IV"
    init        1  "the OS/8 INIT message"
    k12         1  "12-bit Kermit"
    macrel      1  "MACREL assembler"
    music       0  "*.MU files"
    uwfocal     1  "U/W FOCAL (only)"
    vtedit      0  "the TECO VTEDIT setup"
}

set alloptions {}

foreach {opt def desc} $os8opts {
    if {$def} {
        set prefix "disable"
    } else {
        set prefix "enable"
    }
    append alloptions [list os8-$opt=$def => "$prefix $desc in the built OS/8 RK05 image"]
}

# Now define those command line options that belong only to us.
append alloptions {
    alt-serial-mod    => "use GPIO drive scheme suitable for James L-W's serial mod method"
    cc8-cross=1       => "do not build the cc8 cross-compiler on the host"
    debug-mode        => "create a debug build (default is release)"
    lowercase:        => "select how lowercase input is to be handled"
    no-lamp-simulator => "use simple LED driver instead of incandescent lamp simulator"
    os8-focal=1       => "leave FOCAL 69 and U/W FOCAL off the built OS/8 RK05 image"
    os8-minimal       => "set all --disable-os8-* options, giving minimal OS/8 bin disk"
    os8-patches=1     => "do not apply DEC patches to the built OS/8 RK05 bin image"
    os8-src=1         => "do not build os8v3d-src.rk05 from OS/8 source tapes"
    serial-mod        => "use GPIO drive scheme suitable for Oscar Vermeulen's serial mod method"
    throttle:         => "override the throttle values in the boot scripts"
}

options $alloptions

# Make our own array of os8 options so we can apply the meta options
foreach {opt def desc} $os8opts {
    set os8bool($opt) [opt-bool os8-$opt]
}
set os8bool(patches) [opt-bool os8-patches]
set os8bool(src) [opt-bool os8-src]

# Handle meta-options
if {![opt-bool os8-focal]} {
    set os8bool(focal69) 0
    set os8bool(uwfocal) 0
}
if {![opt-bool os8-minimal]} {
    set os8bool(patches) 0
}
# And dependencies
if {$os8bool(cc8) && $os8bool(fortran-ii)} {
    set $os8bool(fortran-ii) 0
    msg-result "Disabling --disable-os8-fortran-ii because CC8 is enabled."
}

# -- do not use opt-bool os8-* below this point
# -- use the os8bool() array

# Now build the options to mkos8
set mkos8_opts ""
# For simplicity, just pass all options to mkos8 even if they are the default
foreach {opt def desc} $os8opts {
    if {$os8bool($opt)} {
        msg-result "Will enable $desc in the built OS/8 RK05 image"
        append mkos8_opts " --enable-$opt"
    } else {
        append mkos8_opts " --disable-$opt"
        msg-result "Will not enable $desc in the built OS/8 RK05 image"
    }
}

# And generate mkos8/opts.py
set os "# GENERATED BY auto.def; DO NOT MODIFY.\n\nopts = {\n"
foreach {opt def desc} $os8opts {
    if {$def} {
        set fulldesc "disable $desc in the built OS/8 RK05 image"
    } else {
        set fulldesc "enable $desc in the built OS/8 RK05 image"
    }
    append os "\t\"" $opt "\": \[ $def, \"" $fulldesc "\" \],\n"
}
append os "}\n"     ; # saved later!

# Handle the OS/8 options not passed to mkos8 generically by above.
if {$os8bool(src)} {
    msg-result "Building os8v3d-src.rk05 from OS/8 source tapes."
    define OS8_SRC_RK05 bin/os8v3d-src.rk05
} else {
    msg-result "Will not build os8v3d-src.rk05 from OS/8 source tapes."
    define OS8_SRC_RK05 {}
}
if {!$os8bool(patches)} {
    msg-result "Will not patch OS/8 on the RK05 bin disk."
    define OS8_BOOT_DISK "os8v3d-bin.rk05"
    define MKOS8_BIN_PATCHES {}
} else {
    msg-result "Will apply OS/8 V3D patches to the RK05 bin disk."
    define OS8_BOOT_DISK "os8v3d-patched.rk05"
    define MKOS8_BIN_PATCHES patch
}

# React to remaining chosen command line options
if {[opt-bool alt-serial-mod]} {
    msg-result "GPIO drive adjusted for James L-W's serial mods to the PiDP-8/I PCB."
    define PCB_SERIAL_MOD_JLW
    define PCB_SERIAL_MOD_ANY
}

if {[opt-bool serial-mod]} {
    msg-result "GPIO drive adjusted for O. Vermeulen's serial mods to the Pi & PiDP-8/I PCBs."
    define PCB_SERIAL_MOD_OV
    define PCB_SERIAL_MOD_ANY
}

if {[opt-bool cc8-cross]} {
    define CC8_CROSS bin/cc8
} else {
    define CC8_CROSS {}
    msg-result "Will not build the cc8 cross-compiler."
}

if {[opt-bool debug-mode]} {
    msg-result "Creating a debuggable build."
    define BUILDMODE {-O0 -g}
} else {
    msg-result "Creating a release build."
    define BUILDMODE {-O2}
}

set lv [opt-val lowercase]
if {$lv == ""} { set lv "auto" }
if {$lv == "auto"} {
    define SIMH_PASS_LOWERCASE
} elseif {$lv == "pass"} {
    define SIMH_PASS_LOWERCASE
    append mkos8_opts " --disable-lcmod"
} elseif {$lv == "upper"} {
    append mkos8_opts " --disable-lcmod"
} else {
    user-error "Legal values for --lowercase are {auto,pass,upper}."
}
msg-result "Lowercase handling set to '$lv' mode."

# We've purposely held off exporting the mkos8 option set until now
# because some of the configuration options can affect the option set.
define MKOS8_OPTS $mkos8_opts
if {![file exists "lib/mkos8"]} { file mkdir "lib/mkos8" }
write-if-changed "lib/mkos8/opts.py" $os

# Force a rebuild of the OS/8 media if the option set changed.
if {![file exists "obj"]} { file mkdir "obj" }
write-if-changed "obj/mkos8.opts" $mkos8_opts {
    file delete -force bin/os8v3d-bin.rk05
    msg-result "mkos8 options changed; will rebuild OS/8 disk images."
}

# High-level definitions
set builddir [get-define builddir]
set srcdir [get-define srcdir]
set cores [exec $srcdir/tools/corecount]

# Translate --throttle value to a SIMH command
set tv [opt-val throttle]
set tvsl [string length $tv]
if {($tvsl == 0 && $cores > 1) || $tv == "none"} {
    define SET_THROTTLE {set nothrottle}
    set tv "unlimited"
} else {
    # Rewrite symbolic values with values SIMH can understand.  See
    # README-throttle.md for the justification of these values.
    if {$tv == "single-core" || $tvsl == 0} {
        # It's a single-core Pi board, so just tell SIMH to take half
        # the host CPU power, leaving the rest left for background
        # tasks.  We can't use an IPS value here for several reasons.
        # See README-throttle.md for details.
        set tv "50%"
    } elseif {$tv == "pdp8e"} {
        set tv "416k"
    } elseif {$tv == "pdp8i" || $tv == "pdp8a"} {
        set tv "333k"
    } elseif {$tv == "pdp8l" || $tv == "pdp8"} {
        set tv "313k"
    } elseif {$tv == "ha6120"} {
        set tv "182k"
    } elseif {$tv == "im6100a"} {
        set tv "200k"
    } elseif {$tv == "im6100"} {
        set tv "100k"
    } elseif {$tv == "im6100c"} {
        set tv "83k"
    } elseif {$tv == "pdp8s"} {
        set tv "63k"
    } elseif {$tv == "human"} {
        set tv "1/100"
    } elseif {$tv == "trace"} {
        set tv "1/1000"
    }
    # else, assume --throttle was given a legal SIMH throttle value
    
    if {[string first "/" $tv] > -1} {
        # Assume the ratio given will push us below 1 kIPS, where ILS
        # fails badly because of the simulator's sleeping behavior, so
        # disable the ILS feature if we were going to build it.
        set cores 1
    }

    define SET_THROTTLE "set throttle $tv"
}
msg-result "Simulator CPU throttle set to $tv"

# Swap the incandescent lamp simulator feature out for the original LED
# driving method on single-core hosts.  The user can force this on
# multi-core hosts via --no-lamp-simulator.
if {($cores < 2) || [opt-bool no-lamp-simulator]} {
    msg-result "Driving PiDP-8/I front panel LEDs using low-CPU-usage method."
    define LED_DRIVER_MODULE n
    define ILS_MODE 0
} else {
    msg-result "Driving PiDP-8/I front panel LEDs using incandescent lamp simulator."
    define LED_DRIVER_MODULE i
    define ILS_MODE 1
}

# Check for headers, functions, etc. whose absence we can work around
cc-check-includes time.h
cc-check-function-in-lib clock_gettime rt
cc-check-functions clock_nanosleep nanosleep usleep
cc-check-functions sched_yield

# Ensure we have the libncurses development files installed here, else
# pidp8i-test won't build.
if {![cc-check-includes curses.h]} {
    user-error "Could not find curses.h.  Try installing libncurses-dev."
} elseif {![cc-check-function-in-lib initscr ncurses]} {
    user-error "Could not find initscr() in libncurses."
}

# We need to find an install(1) type program that supports -D.  The
# Raspberry Pi OSes typically used with the PiDB-8/I board do have this,
# but this package also runs on non-Linux OSes (e.g. for testing on a
# desktop Mac) so make sure we've got a suitable implementation.  The
# ginstall name is typical on non-Linux systems where GNU Coreutils was
# installed alongside the core OS utilities.
if {[cc-check-progs ginstall]} {
    define INSTALL ginstall
} elseif {[cc-check-progs install]} {
    if {[catch {exec install -D -d . >& /dev/null} result] == 0} {
        define INSTALL install
    } else {
        user-error "install(1) does not support -D; install GNU Coreutils."
    }
} else {
    user-error "No install(1) type program found; install GNU Coreutils."
}
msg-result "Found GNU install(1) program as [get-define INSTALL]."

# If we have cscope here, we'll use it in the "tags" target
define HAVE_PROG_CSCOPE [cc-check-progs cscope]

# Remember the name and primary group of the user who installed this, since
# we want to give that group write privileges to some files when they're
# installed, and we want them to own the screen(1) session.
set instgrp [exec id -grn]
set instusr [exec id -urn]
if {$instusr == "root"} {
    msg-result "Error: This software will not install and run as root."
    user-error "Reconfigure without sudo!"
}
define INSTGRP $instgrp
define INSTUSR $instusr
msg-result "Install group for user-writeable files will be $instgrp."
msg-result "Owner of screen(1) session will be $instusr."

# Can we use any nonstandard flags here?  We don't bother including
# flags that both GCC and Clang support.  The ones inside the "if"
# block are those that Clang will accept in an autosetup test but
# then will yell about if you try to use them.  The test checks for
# an -f sub-option that Clang doesn't currently support even enough
# to fool autosetup.
cc-check-standards c99
if {![opt-bool debug-mode]} {
    cc-check-flags -fipa-cp-clone
    cc-check-flags -fno-strict-overflow
    cc-check-flags -fpredictive-commoning
    if ([get-define HAVE_CFLAG_FIPA_CP_CLONE]) {
        cc-check-flags -fgcse-after-reload
        cc-check-flags -finline-functions
        cc-check-flags -fno-unsafe-loop-optimizations
    }
}

# Embed this software's Fossil-based version string into gpio-common.c.
# Fail hard if we can't get this version string because all supported
# configurations require Fossil and work from a Fossil checkout.  Don't
# fall back on some lame "UNKNOWN" version string because that would
# mask a real problem that needs to be diagnosed.
set tool "tools/version"
set cmd "$srcdir/$tool"
set status [catch {exec $cmd} version]
if {$status != 0} {
    # The most likely cause for tools/version to fail is that the repo
    # file has become disassociated from the local checkout directory.
    set sql ".timeout 5000 ; select value from vvar where name=\"repository\""
    set cmd "fossil sql --no-repository $srcdir/.fslckout '$sql'"
    set status [catch {exec /bin/sh -c $cmd} path]
    if {$status != 0} {
        user-error "Fossil doesn't seem to work here.  Is it installed?\nCMD: $cmd"
    } elseif {[file exists $path]} {
        user-error "$tool failed to get checkout version from $path"
    } else {
        user-error "$tool failed: $path does not exist."
    }
}
define VERSION $version

# Get host, user, and date info for use by media/os8/init.tx.
catch {exec hostname} host
set user $::env(USER)
define BUILDUSER "$user@$host"
define BUILDTS [clock format [clock seconds] -format "%Y.%m.%d at %T %Z"]

# The mkos8 script requires Python and some non-core modules.
set status [catch {exec python -c exit} result]
if {$status != 0} {
    user-error "Python does not appear to be installed here.  It is required."
}
msg-result "Python is installed here."
set status [catch {exec python -c "import pexpect" 2> /dev/null} result]
if {$status != 0} {
    set msg "The Python pexpect module is not installed here.  Fix with\n"
    append msg "\n    sudo pip install pexpect\n"
    append msg "\nOR:\n"
    append msg "\n    sudo easy_install pexpect\n"
    append msg "\nOR:\n"
    append msg "\n    sudo apt install python-pexpect\n"
    user-error $msg
}
msg-result "Python module pexpect is installed here."
set status [catch {exec python -c "import pkg_resources" 2> /dev/null} result]
if {$status != 0} {
    set msg "The Python pkg_resources module is not installed here.  Fix with\n"
    append msg "\n    sudo pip install pkg_resources\n"
    append msg "\nOR:\n"
    append msg "\n    sudo easy_install pkg_resources\n"
    append msg "\nOR:\n"
    append msg "\n    sudo apt install python-pkg-resources\n"
    user-error $msg
}
msg-result "Python module pkg_resources is installed here."

# Build Deeper Thought if we find it here
if {[file exists "[get-define srcdir]/src/deeper.c"]} {
    set ls [string toupper "[get-define LED_DRIVER_MODULE]ls"]
    msg-result "Found Deeper Thought; building it against $ls GPIO module"
    define BUILD_DEEPER_THOUGHT 1
}

# Generate autodependency Makefile rule sets.
#
# It is important to list "src" last, because GNU make takes the first
# one that matches, and the wildcards in the generated rules for "src"
# match all "src/*" subdirs.
set status [catch {
    exec $srcdir/tools/mkadrules $srcdir src/cc8/cross src/d8tape src/palbart src/PDP8 src
} result]
if {$status == 0} {
    msg-result $result
} else {
    user-error "Failed to generate autodependency rules: $result!"
}

# Write outputs.
#
# NOTE: If you change the list of files here, change INFILES in
# Makefile.in, too.
make-config-header src/config.h \
    -auto {ENABLE_* HAVE_* PACKAGE_* SIZEOF_*} \
    -bare {ILS_MODE PCB_*}
make-template Makefile.in
make-template bin/pidp8i.in
make-template boot/0.script.in
make-template boot/2.script.in
make-template boot/3.script.in
make-template boot/4.script.in
make-template boot/6.script.in
make-template boot/7.script.in
make-template boot/run.script.in
make-template etc/pidp8i-init.in
make-template etc/sudoers.in
make-template examples/Makefile.in
make-template lib/pidp8i/__init__.py.in
make-template lib/pidp8i/dirs.py.in
make-template lib/pidp8i/ips.py.in
make-template media/os8/init.tx.in
make-template src/Makefile.in
make-template src/cc8/Makefile.in
make-template src/cc8/os8/Makefile.in
make-template src/gpio-common.c.in
make-template src/PDP8/Makefile.in
make-template src/PDP8/pidp8i.c.in
make-template tools/simh-update.in
exec chmod +x "$builddir/tools/simh-update"
