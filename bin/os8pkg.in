#!/usr/bin/env @PYCMD@
# -*- coding: utf-8 -*-
########################################################################
# Packaging software for consumption by OS/8
# Uses os8-cp as a foundation.
#
# See USAGE message below for details.
#
# Copyright Â© 2020 by Bill Cattey and Warren Young
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS LISTED ABOVE BE LIABLE FOR ANY CLAIM,
# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
# OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
# OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# Except as contained in this notice, the names of the authors above
# shall not be used in advertising or otherwise to promote the sale,
# use or other dealings in this Software without prior written
# authorization from those authors.
########################################################################

# Bring in just the basics so we can bring in our local modules
import os
import sys

sys.path.insert (0, os.path.dirname (__file__) + '/../lib')
sys.path.insert (0, os.getcwd () + '/lib')

# Our local modules
from pidp8i import *

# Other global Python modules
import glob
import subprocess
import string
import re
import argparse


#### GLOBALS AND CONSTANTS #############################################

progmsg = True
DEBUG = False
VERBOSE = False
QUIET = False

# Sections found in a pspec file:
_pspec_sections = ["format:", "inputs:", "outputs:", "build:"]

# Supported file formats:
_pspec_formats = ["tu56", "rk05"]

# Default RK05 system image to attach if no sys specified.
_default_sys_image = "@OS8_TOOLTIME@"
_default_sys_path = dirs.os8mo + _default_sys_image
_default_att_spec = ["rk", "0", _default_sys_path]

_pkg_obj_dir = os.path.join (dirs.obj, "os8pkg/")

# Regex for parsing an argument string into a sys device
_dev_arg_regex_str = "-(rk|td|dt|rx)(\d?)(s)?"
_dev_arg_re = re.compile(_dev_arg_regex_str)

# Map of SIMH device names to OS/8 device name prefixes.
_os8_from_simh_dev = {"rk" : "RK", "td" : "DTA", "dt" : "DTA", "rx" : "RX"}

_os8_partitions = {"RK": ["A", "B"]}

# OS/8 file name matching regex
_os8_file_re = re.compile("(\S+):(\S+)?")

# Constrained spec for an outputs: line.
# Group 1 containas the output device: SYS: or DSK:
# Group 2 confirns '<'
# Group 3 contains the input device: DTA1: or RKA1: or RKB1:
# Group 4 contains the input file spec
# Group 5 contains the filename before the dot extension.
# Group 6 contains the dot extension.
# Group 7 if present, contains the option string (currently just /V is allowed.)
_output_spec_re = re.compile("^(SYS:|DSK:)(<)(DTA1:|RKA1:|RKB1:)((\*\.\*|[A-Z0-9?]{0,6})(\.[A-Z0-9?]{0,2}|\.\*)?)(/[V])?$")

# Matches if the string begins with a dollar sign, and has at least
# one slash, returning the string between the dollar sign and the
# first slash in group 1 and the rest in group 2.
# No whitespace in the string.
_expandable_re = re.compile ("^((?:[^/]*/)*)(([^\.]*)(\.pspec)?)$")

_pspec_strip_re = re.compile("^(\S*)\.pspec$")

# Commands and their help strings.
_command_set = [["deps", "Create .mk format dependency file from inputs"],
                ["script", "Create os8-run install script from outputs"],
                ["include", "Create an include script from selected scripts"],
                ["install", "Create target image file"],
                ["build", "Install target image file"],
                ["all", "Perform all of the above."]]


#### abort_prog ########################################################
# Print err_string and exit with -1 return status.

def abort_prog (err_str):
  print("Abort: " + err_str)
  sys.exit(-1)


#### path_expand #######################################################
# Originally developed in os8script.py, but useful here too.
#
# Simple minded variable substitution in a path.
# A path beginning with a dollar sign parses the characters between
# the dollar sign and the first slash seen becomes a name to
# expand with a couple local names: $home and the anchor directories
# defined in lib/pidp8i/dirs.py.
# We abort if the path expansion fails.

def path_expand (path):
  m = re.match(_expandable_re, path)
  if m == None: return path
  var = m.group(1)

  val = getattr (dirs, var, None)
  if val != None:
    return os.path.join(val,m.group(2))
  else:
    abort_prog ("{$" + var + "} is not a valid path expansion in " + path)
  

#### dest_expand ########################################################
# Return a full path based either on the --destdir option or
# the default _pkg_obj_dir

def dest_expand (args, fname):
  if args.destdir: return os.path.join(args.destdir, fname)
  else: return  os.path.join(_pkg_obj_dir, fname)


#### parse_pspec ########################################################
# Parse the pspec file named by pkg

def parse_pspec (pkg_inpath):
  try:
    pspec_file = open (pkg_inpath, "r")
  except IOError:
    print(pkg_inpath + " not found. Skipping.")
    return None

  pspec = {}
  for section in _pspec_sections:
    pspec [section] = []

  pspec["format:"].append("tu56")     # Default to tu56 format.

  location = ""
  for ioline in pspec_file:
    line = ioline.strip()
    if line == "": continue
    elif line[0] == "#": continue
    elif line in _pspec_sections: location = line
    else:
      if location == "":
        print ("Don't know where to put: {" + line + "}.")
      elif location == "format:":
        if line in _pspec_formats:
          pspec[location][0] = line  # Last format we see wins.
        else:
          print ("Unsupported format: " + line)
      else:
        pspec[location].append(line)
  return pspec


#### make_mk ###########################################################
# Make the .mk output file

def make_deps (pkg_name, pspec):
  if len(pspec["inputs:"]) == 0:
    print ("Nothing to make")
    return None

  outstr = ""

  pkg_fmt = pspec["format:"][0]
  pkg_ucfmt = pkg_fmt.upper()
  pkg_srcs = pkg_name.upper() + "_SRCS"
  pkg_script = pkg_name.upper() + "_" + pkg_ucfmt + "_SCRIPT"
  pkg_bin = pkg_name.upper() + "_PKG_BIN"

  outstr += (pkg_srcs + ":= ")
  for src in pspec["inputs:"]:
    outstr += ("\\\n\t@srcdir@/" + src)

  outstr += ("\n\n" + pkg_bin + " = bin/" + pkg_name + "." + pkg_fmt + "\n")

  # If the build section is empty use a default build:
  # An os8-run on a script in MISC_SCRIPTS_DIR named like the package and format.
  if len(pspec["build:"]) > 0:
    outstr += ("\n\n$(" + pkg_bin + ") : $(" + \
               pkg_srcs + ") | $(OS8_TOOLTIME)\n")
    for build_line in pspec["build:"]:
      outstr += ("\t" + build_line)

    outstr += "\n"
  else:
    outstr += ("\n" + pkg_script + " =  $(MISC_SCRIPTS_DIR)/" + pkg_name + \
               "-" + pkg_fmt + ".os8\n")
  
    outstr += ("\n$(" + pkg_bin + ") : $(" + \
               pkg_srcs + ") $(" + pkg_script + ") | $(OS8_TOOLTIME)\n")
    outstr += ("\t$(OS8RUN) $(" + pkg_script + ")\n")

  return outstr

#### make_os8 ##########################################################
# Make the installer .os8 file

def make_script (pkg_name, pspec):
  if len(pspec["outputs:"]) == 0:
    print ("Nothing to make")
    return None

  pkg_fmt = pspec["format:"][0]
  if pkg_fmt == "tu56": dev = "dt1"
  else: dev = "rk1"
  
  outstr = "mount " + dev + " $os8mo/" + pkg_name + "." + pkg_fmt + " ro required\n"
  for dest in pspec["outputs:"]:
    m = re.match (_output_spec_re, dest)
    if m == None: print ("Mal-formed output: spec: " + dest + ". Ignored.")
    outstr += ("os8 COPY " + dest + "\n")

  outstr += ("umount " + dev + "\n")
  return outstr


#### main ##############################################################

def main ():

  parser = argparse.ArgumentParser(
    description = """
    Package manager for use under PDP-8 OS/8.""",
    usage = "%(prog)s [options] [command] [package ...]")
  parser.add_argument("-v", "--verbose", help="increase output verbosity",
  				   action="store_true")
  parser.add_argument("-d", dest="debug", metavar="DEBUG", type=int,
                      help="set debug level", default=0)
  parser.add_argument("--destdir", help="Destination directory for output files")
  parser.add_argument ("--target", help="target image file")
  parser.add_argument ("--dry-run", "-n", action="store_true", help="Dry Run. Print output. Generate no files.")

  subparsers = parser.add_subparsers(title="commands")

  for pair in _command_set:
    name = pair[0]
    the_help = pair[1]

    the_sub = subparsers.add_parser (name, help=the_help)
    the_sub.add_argument ('packages', nargs=argparse.REMAINDER, metavar="one or more package files")
    the_sub.set_defaults (command=name)
  
  args = parser.parse_args()

  if hasattr(args, 'command') == False:
    print (parser.print_help())
    sys.exit(-1)

  if args.command == "include":
    # We're going to assemble obj/os8pkg/pkgs.os8 from the proffered list of packages.
    outpath = dest_expand (args, "pkgs.os8")
    if args.debug >0 or args.dry_run:  print (outpath)
    if len(args.packages) == 0:
      first_line = "# No packages to include"
    else:
      first_line = "# Packages to include"
    
    if args.dry_run:
      print (first_line)
    else:
      outfile = open (outpath, "w")
      outfile.write(first_line + "\n")
      
  else:
    # All other commands require one package.
    if len(args.packages) == 0:
      abort_prog ("Need at least one package to work.")

  # The pkg_spec from command line may be a package name, or a file path.
  # We need the name, and may or may not get the ".pspec" at the end.
  for pkg_spec in args.packages:
    pkg_dir = os.path.dirname(pkg_spec)
    pkg_base = os.path.basename(pkg_spec)
    m = re.match(_pspec_strip_re, pkg_base)
    if m == None: pkg_name = pkg_base
    else: pkg_name = m.group(1)
    if args.debug >0:  print ("Package name:" + pkg_name)

    if args.command in ["deps", "script"]:
      # Not all commands need parsing of pspec.
      pkg_inpath = os.path.join(pkg_dir,  pkg_name + ".pspec")
      pspec = parse_pspec(pkg_inpath)
      if pspec == None: continue

      pkg_fmt = pspec["format:"][0]
      if args.debug >0:  print ("Format: " + pkg_fmt)

    if args.command == "deps":
      outname = (pkg_name + ".mk")
      outpath = dest_expand (args, outname)
      if args.debug >0 or args.dry_run:  print (outpath)
      outstr = make_deps(pkg_name, pspec)
      if args.dry_run:
        print (outstr)
      else:
        outfile = open (outpath, "w")
        for line in outstr:
          outfile.write(line)
        outfile.close()

    if args.command == "script":
      outname = pkg_name + ".os8"
      outpath = dest_expand (args, outname)
      if args.debug >0:  print (outpath)
      outstr = make_script(pkg_name, pspec)
      if args.dry_run:
        print (outstr)
      else:
        outfile = open (outpath, "w")
        for line in outstr:
          outfile.write(line)
        outfile.close()

    if args.command == "include":
      # Use the list of pkgnames to concatenate the relevant .os8 scripts.
      inpath = dest_expand (args, pkg_name + ".os8")
      try:
        infile = open(inpath, "r")
      except IOError:
        print(inpath + " not found. Skipping.")
        continue
      if args.dry_run:
        print ("infile: " + inpath)
      else:
        outfile.write ("# Install: " + inpath + "\n")
      for line in infile:
        if args.dry_run:
          print (line.strip())
        else:
          outfile.write (line)
      if args.dry_run == False:
        outfile.write("\n")
      infile.close()

  if args.command == "include" and args.dry_run == False:
    outfile.close()

if __name__ == "__main__": main()
