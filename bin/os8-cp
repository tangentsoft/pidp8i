#!/usr/bin/python
# -*- coding: utf-8 -*-
########################################################################
# Generalized facility to manipulate os8 device images from Linux
# using OS8 system programs under SIMH.
#
# Currently understands .tu56, and .rk05 images.
#
# Arguments specify:
#    exactly sys one image to attach and boot.
#          Zero or more than 1 is an error.
#          Nonexistent image is an error.
#    zero or more additional OS/8 device images to attach.
#          Nonexistent image creates a new one and initializes it.
#          New image files with multiple partitions initializes all of them.
#    zero or more OS/8 file specifications.
#    zero or more Linux file specifications.
#    interpretation/translation to make of file formats.
#
# Depending on the count of OS/8 and Linux file specifications
# an "action plan" is formulated to copy or move files
# either between Linux and OS/8 or within OS/8.
#
# Current implementation uses PIP on the OS/8 side
# to read from simh ptr device and write to simh ptp device
# which will get linux files attached.
#
# Permits input or output file ames to be specified on the command line
# or in list files. <- May not implement.
#
# Will handle /A (ASCII (with POSIX conversion)),/B (.BN, OS/8 bin format),
# and /I (PIP image mode for .SV files.)
#
# Consider adding support of /Y to copy system head in or out.
#
# Case fold rules:
# File name specifications in all UPPER case will be kept upper case
# on the linux side.
#
# File name specifications with any lower case letters will be
# upcased when sent to OS/8 for processing, but will be used as-is
# on the linux side.
#
# Examples:
# -i foo.pa will input a linux file, 'foo.pa' to 'FOO.PA' on OS/8.
# -i FOO.PA will input a linux file, 'FOO.PA' to 'FOO.PA' on OS/8.
# -o FOO.PA will output an OS/8 file, 'FOO.PA' to linux as 'FOO.PA'.
# -o foo.pa will output an OS/8 file, 'FOO.PA' to linux as 'foo.pa'.
#
# What about overwrites?
# Pre-existing image files will be modified, not wiped.
# Pre-existing files will be overwritten.
# Consider warning of overwrites.
# Consider forbidding overwrites unless -p (permit) option is set.
#
# Copyright Â© 2018 by Bill Cattey
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS LISTED ABOVE BE LIABLE FOR ANY CLAIM,
# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
# OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
# OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# Except as contained in this notice, the names of the authors above
# shall not be used in advertising or otherwise to promote the sale,
# use or other dealings in this Software without prior written
# authorization from those authors.
########################################################################

# Bring in just the basics so we can bring in our local modules
import os
import glob
import sys
import string
import re
import argparse

sys.path.insert (0, os.path.dirname (__file__) + '/../lib')
sys.path.insert (0, os.getcwd () + '/lib')

# Our local modules
from pidp8i import *
from simh   import *

# Other global Python modules
import glob
import subprocess


#### GLOBALS AND CONSTANTS #############################################

progmsg = True
DEBUG = False

_os8_file_regex_str = "(\S+):(\S+)?"
_os8_file_re = re.compile(_os8_file_regex_str)


#### UTILITY ROUTINES ##################################################

#### extract_option ####################################################
#
# Given a filename, Look for a PIP option prefix:
#
#   :a    for ASCII
#   :b    for .BN OS/8 BIN format.
#   :i    for IMAGE for use with .SV files.
#   :y    Later: For work with system area.
#
# Returns two values: updated fname, and the option string.
# Option string may be empty.

def extract_option (fname):
  if fname[1] != ':': return fname, ""              # No option. Return fname unchanged.
    
  if fname[0] == 'a' or fname[0] == 'A':        # ASCII mode
    return fname[2:], "/A"
  elif fname[0] == 'b' or fname[0] == 'B':     # BIN mode.
    return fname[2:], "/B"
  elif fname[0] == 'i' or fname[0] == 'I':     # IMAGE mode.
    return fname[2:], "/I"
  # elif fname[0] == 'y' or fname[0] == 'Y':    # SYS HEAD mode.
  #   return fname[2:], "/Y"
  else:
    print "Unknown format option: " + fname[0] + " in fname spec: " + fname + " will default to ASCII."
  return fname[2:], ""

def fetch_one (s, os8dev, oname):
  if debug: print "\t" + oname
  fname, option = extract_option(oname)
  if debug: print "Option: " + option + ", fname: " + fname
  s.os8_fetch_pip(os8dev, fname, option)

def send_one (s, os8dev, iname):
  if debug: print "\t" + iname
  fname, option = extract_option(iname)
  if debug: print "Option: " + option + ", fname: " + fname
  s.os8_send_pip(os8dev, fname, option)

def is_directory(path):
  if DEBUG: "is_directory (" + path + ")"
  m = re.match(_os8_file_re, path)
  if m != None:
    if DEBUG: print "OS/8 Match: DEV: " + m.group(1) + ", File: " + str(m.group(2))
    if m.group(2) == None or m.group(2) == "": 
      return True     # Just a device so yes it's a directory.
    else: return False
  if has_os8_wildcards(path):
    if DEBUG: print "Has wildcards."
    return False
  return os.path.isdir(path)

def has_os8_wildcards (filename):
  os8_wild_cards = "*?"
  for char in os8_wild_cards:
    if char in filename: return True
  return False

def append_copy(action_plan, mode, source, destination):
  if ":" in source:
    if "/" in source:
      print "Illegal OS/8 file spec containing a slash:" + source
      sys.exit(-1)
    source = source.upper()

  if ": in destination":
    if "/" in destination:
      print "Illegal OS/8 file spec containing a slash:" + destination
      sys.exit(-1)
    destination = destination.upper()
    
  copyspec = [mode, source, destination]
  action_plan["copy"].append (copyspec)
  

#### main ##############################################################
#
# Builds the action plan from the command line arguments and executes it
#
# An element of the "copy" array is itself an array
# that names a file format, a source, and a destination.
# [<format>, <source>, <destination>]
#
# source and destination file specifications are as follows:
# If it has a colon in it, it's an OS/8 spec with OS/8
# device to the left of the colon, and filename to the right.
# No colon means it's a Linux file spec.
#
# The parser may make an interpretation of file spec. contexts
# that get synthesized into an OS/8 spec with "DSK:" as the device.
#
# Cases to handle:
#
# only 2 file specs, 1 OS/8, 1 Linux:
#    Simplest.
#    The first one seen is the source
#    The second one is the destination.
# only 2 file specs, No OS/8:
#    Special Case
#    Convert both to DSK: for an OS/8 to OS/8 transfer.
# only 1 file spec, Syntax Error.
# More than 2 specs:

# regex for parsing an argument string into a sys device

USAGE = """ Place Holder 
"""

_dev_arg_regex_str = "-(rk|td|tc|rx)(\d?)(s)?"
_dev_arg_re = re.compile(_dev_arg_regex_str)

_os8_from_simh_dev = {"rk" : "RK", "td" : "DTA", "tc" : "DTA", "rx" : "RX"}

def main():
  global DEBUG
  action_plan = {}
  action_plan["sys"] = None
  action_plan["mount"] = []
  action_plan["copy"] = []

  idx = 1
  numargs = len(sys.argv)

  filespec_seen = 0
  mode_opt = "b"                              # start of with default of binary.
  first_mode = mode_opt
  source = ""
  destination = ""
  # Keep file_list and mode_list in sync.
  file_and_mode_list = []
  
  while idx < numargs:
    print "idx: " + str(idx)
    arg = sys.argv[idx]

    # First the simple bit set options
    if arg == "-d":
      DEBUG = True
    elif arg == "-h":
      print USAGE
      sys.exit(0)
    elif arg== "-b":
      if mode_opt == "b":
        print "Warning redundant reset of mode option to binary."
      mode_opt = "b"
    elif arg== "-a":
      if mode_opt == "a":
        print "Warning redundant reset of mode option to ASCII."
      mode_opt = "a"
    elif arg== "-i":
      if mode_opt == "i":
        print "Warning redundant reset of mode option to image."
      mode_opt = "b"
    elif arg== "-y":
      if mode_opt == "y":
        print "Warning redundant reset of mode option to Yank system head."
      mode_opt = "y"
    elif arg== "-z":
      if mode_opt == "z":
        print "Warning redundant reset of mode option to Zero directory."
      mode_opt = "z"

    # Not a simple bit set option. 
    else:
      # Parser for OS/8 attach spec.
      m = re.match(_dev_arg_re, arg)
      if m != None:
        if m.group(2) == None or m.group(2) == "":
          print "Need unit number for: " + m.group(1) + ". Abort."
          sys.exit(-1)
        if idx + 1 == numargs:             # Need filename, but no args left.
          print "No image file name. Abort."
          sys.exit(-1)
        idx +=1
        imagename = sys.argv[idx]
        image_spec = [m.group(1), m.group(2), imagename]
        if m.group(3) == 's': 
          if action_plan ["sys"] != None:
            print "Already specified system device. Abort."
            sys.exit(-1)
          else:
            action_plan["sys"] = image_spec
        else:
          action_plan["mount"].append(image_spec)

      # Do file parser if we didn't get an OS/8 attach spec.
      else:

        if DEBUG: print "File parsing of: " + arg
        
        # Need to know if arg is Linux. If so, we need to do globbing.
        # If you want OS/8 globbing, specify a device to prevent globbing
        # from being run.
        m = re.match(_os8_file_re, arg)
        if m == None:          # Yup, it's linux.  Glob it.
          more_files = glob.glob(arg)
          if more_files == []:
            more_files.append(arg)  # If file not found may be an OS/8 internal xfer.
          for new_file in more_files:
            if filespec_seen == 0:
              source = new_file
              first_mode = mode_opt
            elif filespec_seen == 1:
              destination = new_file  
            else:
              file_and_mode_list.append([mode_opt,destination])
              destination = new_file
            filespec_seen += 1
        else:
          if filespec_seen == 0:
            source = arg
            first_mode = mode_opt
          elif filespec_seen == 1:
            destination = arg
          else:
            file_and_mode_list.append([mode_opt, destination])
            destination = arg
          filespec_seen += 1

    if DEBUG: print "filespec_seen: " + str(filespec_seen)

    idx +=1        # Bottom of the while loop. Increment.

  if filespec_seen == 0:
    print "No file specs seen.  Nothing to do. Abort."
    sys.exit(1)
  elif filespec_seen == 1:
    print "Only 1 file spec found. Nothing to do. Abort."
    sys.exit(1)
  # Now it gets a little complicated...
  # If neither source nor destination is OS/8, pretend they both were OS/8 "DSK:"
  # If source is OS/8, and has OS/8 wild cards, the destination must be a directory.
  else:
    # If more than 2 files, the destination must be either an OS/8 device or a Linux directory.
    if DEBUG: print "Destination: " + destination
    if filespec_seen > 2 and is_directory(destination) == False:
      print "Destination must be a Linux directory or OS/8 device for multiple source files.  Abort."
      sys.exit(-1)

    m1 = re.match(_os8_file_re, source)
    m2 = re.match(_os8_file_re, destination)

    # If source is OS/8 and it has wild cards, but destination is a file, not a device,
    # it's a fatal error.
    if m1 != None and has_os8_wildcards(source) and is_directory (destination) == False:
      print "Not going to concatinate multiple OS/8 files into: " + destination + ". Abort."
      sys.exit(-1)


    if m1 == None and m2 == None and filespec_seen == 2:      # No OS/8 dev on two names, local DSK: copy.
      source = "DSK:" + source
      destination = "DSK:" + destination
      
    append_copy(action_plan, first_mode, source, destination)
    
    for mode_and_file in file_and_mode_list:
      filename = mode_and_file[1]
      m3 = re.match(_os8_file_re, filename)
      if m3 != None and has_os8_wildcards(filename) and is_directory (destination) == False:
        print "Not going to concatinate multiple OS/8 files into: " + destination + ". Abort."
        sys.exit(-1)
      append_copy(action_plan, mode_and_file[0], filename, destination)


  if DEBUG: print str(action_plan)


if __name__ == "__main__": main()
