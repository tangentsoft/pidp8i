#!/usr/bin/python
# -*- coding: utf-8 -*-
########################################################################
# Generalized facility to manipulate os8 device images from the POSIX
# (host) side using OS/8 system programs under SIMH.
#
# See USAGE message below for details.
#
# Copyright Â© 2018 by Bill Cattey and Warren Young
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS LISTED ABOVE BE LIABLE FOR ANY CLAIM,
# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
# OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
# OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# Except as contained in this notice, the names of the authors above
# shall not be used in advertising or otherwise to promote the sale,
# use or other dealings in this Software without prior written
# authorization from those authors.
########################################################################

# Bring in just the basics so we can bring in our local modules
import os
import glob
import sys
import string
import re
import argparse

sys.path.insert (0, os.path.dirname (__file__) + '/../lib')
sys.path.insert (0, os.getcwd () + '/lib')

# Our local modules
from pidp8i import *
from simh   import *

# Other global Python modules
import glob
import subprocess


#### GLOBALS AND CONSTANTS #############################################

progmsg = True
DEBUG = False

_os8_file_regex_str = "(\S+):(\S+)?"
_os8_file_re = re.compile(_os8_file_regex_str)


#### UTILITY ROUTINES ##################################################

def is_directory(path):
  if DEBUG: "is_directory (" + path + ")"
  m = re.match(_os8_file_re, path)
  if m != None:
    if DEBUG: print "OS/8 Match: DEV: " + m.group(1) + ", File: " + str(m.group(2))
    if m.group(2) == None or m.group(2) == "": 
      return True     # Just a device so yes it's a directory.
    else: return False
  if has_os8_wildcards(path):
    if DEBUG: print "Has wildcards."
    return False
  return os.path.isdir(path)

def has_os8_wildcards (filename):
  os8_wild_cards = "*?"
  for char in os8_wild_cards:
    if char in filename: return True
  return False

def append_copy(action_plan, mode, source, destination):
  if ":" in source:
    if "/" in source:
      print "Illegal OS/8 file spec containing a slash:" + source
      sys.exit(-1)
    source = source.upper()

  if ": in destination":
    if "/" in destination:
      print "Illegal OS/8 file spec containing a slash:" + destination
      sys.exit(-1)
    destination = destination.upper()
    
  copyspec = [mode, source, destination]
  action_plan["copy"].append (copyspec)
  

#### main ##############################################################
#
# Builds the action plan from the command line arguments and executes it
#
# An element of the "copy" array is itself an array
# that names a file format, a source, and a destination.
# [<format>, <source>, <destination>]
#
# source and destination file specifications are as follows:
# If it has a colon in it, it's an OS/8 spec with OS/8
# device to the left of the colon, and filename to the right.
# No colon means it's a Linux file spec.
#
# The parser may make an interpretation of file spec. contexts
# that get synthesized into an OS/8 spec with "DSK:" as the device.
#
# regex for parsing an argument string into a sys device

USAGE = 'usage: ' + os.path.basename (__file__) + \
""" [-dh] [-B boot-image] [-r,--rk rotating-disk] [-t,--dt,--td tape]
    [[-abiyz] src-files]... [src-files] <dest>

    This program boots an OS/8 environment underneath the SIMH PDP-8
    simulator then tries to behave like the POSIX program we are named
    after, either copying files from the POSIX (host) side into the
    simulated OS/8 environment, copying files out of OS/8 to the POSIX
    side, or copying filoes within the OS/8 world from one volume to
    another.

    The copying direction is determined by which file name arguments
    have a colon in them:

    *   copy-within: The source and destination file arguments have
        colons, so copy within the OS/8 environment from one volume to
        another.

    *   copy-into: Only the dest argument has a colon, so assume the
        source file names are POSIX-side and copy those files into the
        simulated OS/8 environment.

    *   copy-out: The dest argument has no colon but the source file
        names do, so copy the named OS/8 files out of the simulation.

    If none of the file arguments has a colon in it and you give exactly
    two such arguments, we operate in a special case of copy-within
    mode: the source and destination volumes are assumed to be DSK:, so
    the file is simply copied within the OS/8 DSK: volume from one name
    to the other.  If you give greater than two file name arguments
    without a colon in any of them, it is not possible to make sense of
    the command since we do not intend to try and replace your perfectly
    good POSIX cp implementation, so it errors out.

    If you give only one file name argument, the program always errors
    out: it requires at least one source and one destination.

    The -a, -b, -i, -y, and -z flags correspond to the OS/8 PIP options
    /A, /B, /I, /Y, and /Z, which are passed to PIP as-is.  (This
    priogram currently uses PIP as its primary handler for the OS/8 side
    of the work.)  They must be followed by at least one source file
    name, and they affect all subsequent source file names until another
    such option is found.  For example:

        $ os8-cp -a foo bar -b qux sys:

    Files foo and bar are copied to SYS: in ASCII mode, overriding the
    default binary mode, then binary mode is restored for the copy of
    file qux to the SYS: volume.

    Beware that -i means something very different to this program than
    it means to POSIX cp: destination files will be unceremoniously
    overwritten!

    If -B is given, it overrides the default boot disk for the SIMH PDP-8
    simulator, $prefix/shared/media/os8/os8v3d-patched.rk05.  The file
    name's extension is used to determine which device to attach it to.

    If -r or --rk is given, the named rotating disk image is attached to
    the simulator on the first free disk controller.  Since the default
    for -B attaches to RK0, the first --rk option given attaches to RK1
    unless you give a non-RK05 disk image with -B.  The -r option is a
    generic rotating disk image flag which will use the file extension
    to determine the device type after we add --rf, --rx, etc.

    Therefore, the following:

        $ os8-cp -B foo.tu56 -r my.rk05 foo DSK:

    ...will boot from foo.tu56, which is presumed to be a bootable OS/8
    DECtape attached to DT0 with my.rk05 attached to RK0.  It will then
    copy POSIX-side file foo to DSK:FOO which will probably be
    interpreted as DTA0:FOO by typical configurations for a bootable
    OS/8 DECtape.  Beware therefore of using the generic SYS: and DSK:
    device names with -B when you are not certain of the BUILD
    configuration for the boot media!

    Destination OS/8 volumes are modified in place, rather than
    recreated.  The volume must therefore exist before this program
    runs.

    When only a destination device, directory, or volume name is given,
    file names are normalized when coping between POSIX and OS/8
    systems.  File names are uppercased and truncated to 6.2 limits when
    copying from POSIX to OS/8.  File names are lowercased on copying
    from OS/8 to the POSIX side unless you give the *source* file name
    in all-uppercase; then, file name case is preserved.  This behavior
    is overridden if you give a complete file name for the destination:

        $ os8-cp my-long-file-name.txt DSK:MLF.FD

    If you gave "DSK:" as the destination instead, you would have gotten
    "MY-LON.TX" as the desintation file name instead.

    Give -d to run in debug mode.

    Give -h to print this message.
"""

_dev_arg_regex_str = "-(rk|td|tc|rx)(\d?)(s)?"
_dev_arg_re = re.compile(_dev_arg_regex_str)

_os8_from_simh_dev = {"rk" : "RK", "td" : "DTA", "tc" : "DTA", "rx" : "RX"}

def main ():
  global DEBUG
  action_plan = {}
  action_plan["sys"] = None
  action_plan["mount"] = []
  action_plan["copy"] = []

  idx = 1
  numargs = len(sys.argv)

  filespec_seen = 0
  mode_opt = "b"                              # start of with default of binary.
  first_mode = mode_opt
  source = ""
  destination = ""
  # Keep file_list and mode_list in sync.
  file_and_mode_list = []
  
  while idx < numargs:
    print "idx: " + str(idx)
    arg = sys.argv[idx]

    # First the simple bit set options
    if arg == "-d":
      DEBUG = True
    elif arg == "-h":
      print USAGE
      sys.exit(0)
    elif arg== "-b":
      if mode_opt == "b":
        print "Warning redundant reset of mode option to binary."
      mode_opt = "b"
    elif arg== "-a":
      if mode_opt == "a":
        print "Warning redundant reset of mode option to ASCII."
      mode_opt = "a"
    elif arg== "-i":
      if mode_opt == "i":
        print "Warning redundant reset of mode option to image."
      mode_opt = "b"
    elif arg== "-y":
      if mode_opt == "y":
        print "Warning redundant reset of mode option to Yank system head."
      mode_opt = "y"
    elif arg== "-z":
      if mode_opt == "z":
        print "Warning redundant reset of mode option to Zero directory."
      mode_opt = "z"

    # Not a simple bit set option. 
    else:
      # Parser for OS/8 attach spec.
      m = re.match(_dev_arg_re, arg)
      if m != None:
        if m.group(2) == None or m.group(2) == "":
          print "Need unit number for: " + m.group(1) + ". Abort."
          sys.exit(-1)
        if idx + 1 == numargs:             # Need filename, but no args left.
          print "No image file name. Abort."
          sys.exit(-1)
        idx +=1
        imagename = sys.argv[idx]
        image_spec = [m.group(1), m.group(2), imagename]
        if m.group(3) == 's': 
          if action_plan ["sys"] != None:
            print "Already specified system device. Abort."
            sys.exit(-1)
          else:
            action_plan["sys"] = image_spec
        else:
          action_plan["mount"].append(image_spec)

      # Do file parser if we didn't get an OS/8 attach spec.
      else:

        if DEBUG: print "File parsing of: " + arg
        
        # Need to know if arg is Linux. If so, we need to do globbing.
        # If you want OS/8 globbing, specify a device to prevent globbing
        # from being run.
        m = re.match(_os8_file_re, arg)
        if m == None:          # Yup, it's linux.  Glob it.
          more_files = glob.glob(arg)
          if more_files == []:
            more_files.append(arg)  # If file not found may be an OS/8 internal xfer.
          for new_file in more_files:
            if filespec_seen == 0:
              source = new_file
              first_mode = mode_opt
            elif filespec_seen == 1:
              destination = new_file  
            else:
              file_and_mode_list.append([mode_opt,destination])
              destination = new_file
            filespec_seen += 1
        else:
          if filespec_seen == 0:
            source = arg
            first_mode = mode_opt
          elif filespec_seen == 1:
            destination = arg
          else:
            file_and_mode_list.append([mode_opt, destination])
            destination = arg
          filespec_seen += 1

    if DEBUG: print "filespec_seen: " + str(filespec_seen)

    idx +=1        # Bottom of the while loop. Increment.

  if filespec_seen == 0:
    print "No file specs seen.  Nothing to do. Abort."
    sys.exit(1)
  elif filespec_seen == 1:
    print "Only 1 file spec found. Nothing to do. Abort."
    sys.exit(1)
  # Now it gets a little complicated...
  # If neither source nor destination is OS/8, pretend they both were OS/8 "DSK:"
  # If source is OS/8, and has OS/8 wild cards, the destination must be a directory.
  else:
    # If more than 2 files, the destination must be either an OS/8 device or a Linux directory.
    if DEBUG: print "Destination: " + destination
    if filespec_seen > 2 and is_directory(destination) == False:
      print "Destination must be a Linux directory or OS/8 device for multiple source files.  Abort."
      sys.exit(-1)

    m1 = re.match(_os8_file_re, source)
    m2 = re.match(_os8_file_re, destination)

    # If source is OS/8 and it has wild cards, but destination is a file, not a device,
    # it's a fatal error.
    if m1 != None and has_os8_wildcards(source) and is_directory (destination) == False:
      print "Not going to concatinate multiple OS/8 files into: " + destination + ". Abort."
      sys.exit(-1)


    if m1 == None and m2 == None and filespec_seen == 2:      # No OS/8 dev on two names, local DSK: copy.
      source = "DSK:" + source
      destination = "DSK:" + destination
      
    append_copy(action_plan, first_mode, source, destination)
    
    for mode_and_file in file_and_mode_list:
      filename = mode_and_file[1]
      m3 = re.match(_os8_file_re, filename)
      if m3 != None and has_os8_wildcards(filename) and is_directory (destination) == False:
        print "Not going to concatinate multiple OS/8 files into: " + destination + ". Abort."
        sys.exit(-1)
      append_copy(action_plan, mode_and_file[0], filename, destination)


  if DEBUG: print str(action_plan)


if __name__ == "__main__": main()
