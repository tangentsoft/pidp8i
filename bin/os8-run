#!/usr/bin/python
# -*- coding: utf-8 -*-
########################################################################
# Script runner for OS/8 under SIMH.
# The library module os8script.py does the heavy lifting.
#
# See USAGE message below for details.
#
# Copyright Â© 2018 by Bill Cattey and Warren Young
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS LISTED ABOVE BE LIABLE FOR ANY CLAIM,
# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
# OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
# OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# Except as contained in this notice, the names of the authors above
# shall not be used in advertising or otherwise to promote the sale,
# use or other dealings in this Software without prior written
# authorization from those authors.
########################################################################

# Bring in just the basics so we can bring in our local modules
import os
import sys

sys.path.insert (0, os.path.dirname (__file__) + '/../lib')
sys.path.insert (0, os.getcwd () + '/lib')

# Remaining Python core modules
import subprocess
import string
import re
import shutil
import argparse
from itertools import chain


# Our local modules
from pidp8i import *
from simh   import *
from os8script import *
from mkos8 import opts


#### GLOBALS AND CONSTANTS #############################################

DEBUG = False
VERBOSE = True
QUIET = False
SCRIPT_FILE = ""

USAGE = "usage: "  + os.path.basename (__file__) + \
      " [-dhvq] script [script] ... [-o option] ..."

_en_dis_arg_re = re.compile("^(enable|disable)_(\S+)$")


def opt_set(en_dis, option, options_enabled, options_disabled):
  if option == None or en_dis == None: return
  # print en_dis + " " + option
  if en_dis == "enable":
    if option not in options_enabled:
      options_enabled.append(option)
    if option in options_disabled:
        options_disabled.remove(option)
  elif en_dis == "disable":
    if option not in options_disabled:
      options_disabled.append(option)
    if option in options_enabled:
        options_enabled.remove(option)
  else: return

#### parse_args ########################################################

def parse_args(script_files, options_enabled, options_disabled):
  global DEBUG
  global VERBOSE
  
  ap = argparse.ArgumentParser(description = "Run OS/8 scripts")

  # Add general-purpose args
  ap.add_argument ('-d', '--debug', action = 'store_true', default = False,
                   help = 'add extra debugging output, normally suppressed')
  ap.add_argument ('-v', '--verbose',action = 'store_true', default = False,
                   help = 'verbose SIMH output instead of progress messages')

  # Add arguments corresponding to --*-os8-* configure script options
  for obn, vals in opts.opts.iteritems():
    od = 'dis' if vals[0] else 'en'
    ap.add_argument ('--' + od + 'able-' + obn, action = 'store_true', default = False, help = vals[1])

  # Add options that do not exactly mirror configuration options
  ap.add_argument ('--disable-lcmod', action = 'store_true', default = False,
               help = 'disable the OS/8 command upcasing patch; best set ' +
               'when SIMH is set to tti ksr mode')

  # Add the ability to feed in options.
  ap.add_argument("--enable", nargs=1, action='append' )
  ap.add_argument("--disable", nargs=1, action='append' )

  
  # Add trailing "what do do" argument
  ap.add_argument (
    'script_files',
    help    = "Script files to run",
    nargs   = argparse.REMAINDER)
  
  # Finish initializing
  args = ap.parse_args()

  arg_dict = vars(args)

  VERBOSE = args.verbose
  DEBUG = args.debug

  for key in arg_dict:
    # print key + ": " + str(arg_dict[key])
    m = re.match(_en_dis_arg_re, key)
    if m != None:
      en_dis = m.group(1)
      option = m.group(2)
      if arg_dict[key]: opt_set(en_dis, option, options_enabled, options_disabled)
    else:
      if (key == "enable" or key == "disable") and arg_dict[key] != None:
        options_list = list(chain(*arg_dict[key]))
        for my_option in options_list:
          opt_set(key, my_option, options_enabled, options_disabled)
      elif key == "script_files":
        for filename in arg_dict[key]:
          script_files.append(filename)


    
def add_bool (self, *args, **kwargs):
  kwargs['action']  = 'store_true'
  kwargs['default'] = False
  self.add_argument (*args, **kwargs)
  

def old_parse_args (script_files, options_enabled):
  global DEBUG
  global VERBOSE
  global QUIET

  idx = 1
  numargs = len(sys.argv)

  if numargs < 2:
    print USAGE
    sys.exit(-1)

  # Maybe we should allow more than just one script file?
      
  retval = sys.argv[1]
  
  while idx < numargs:
    arg = sys.argv[idx]
    # print "idx: " + str(idx) + ", arg: " + arg
    # print "Files: " + str(script_files)
    # print "Options: " + str(options_enabled)
    if arg == "-d":
      DEBUG = True
    elif arg == "-h":
      print USAGE
      sys.exit(0)
    elif arg == "-q":
      QUIET = True
    elif arg == "-v":
      VERBOSE = 1
    elif arg == "-o" or arg == "--option":
      idx +=1
      if idx == numargs:
        print "expecting an option but got none."
      else:
        option = sys.argv[idx]
        # Only add the option once
        if option not in options_enabled: options_enabled.append(option)
    else:
      script_files.append(arg)
    idx += 1
      
  return retval


#### main ##############################################################
# Program entry point.  Parses the command line and drives the above.

def main ():
  script_files = []
  options_enabled = []
  options_disabled = []

  parse_args (script_files, options_enabled, options_disabled)
  if len(script_files) == 0:
    print "Need a script file to run."
    sys.exit(-1)

  print "script_files: " + str(script_files)
  print "options_enabled" + str(options_enabled)
  print "options_disabled" + str(options_disabled)
  
  # Log SIMH and OS/8 output to a file by default, but send it to the
  # console instead of the progress messages if -v was given using the
  # trick from https://stackoverflow.com/questions/21239338
  s = simh (dirs.build, True)
  s.set_logfile (open (dirs.log + 'os8-run' + '.log', 'w') \
      if VERBOSE else os.fdopen (sys.stdout.fileno (), 'w', 0))

  os8 = os8script (s, options_enabled, options_disabled, verbose=VERBOSE, debug=DEBUG)

  for script_file in script_files:
    os8.run_script_file (script_file)
  
  s.quit ()
  if VERBOSE: print "Done!"

  
if __name__ == "__main__":
    main()
