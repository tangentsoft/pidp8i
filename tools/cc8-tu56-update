#!/usr/bin/env python
# -*- coding: utf-8 -*-
########################################################################
# cc8-tu56-update - Rebuilds cc8.tu56 from source code.
#
# It is intended to be be called manually whenever a file in src/cc8/os8
# changes.  It is not called automatically from the top-level Makefile
# because not all end user systems will be able to run it, since our
# dependencies (host-side cc8 and SABR) are not always present.
#
# Copyright Â© 2017 by Warren Young and Bill Cattey.
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS LISTED ABOVE BE LIABLE FOR ANY CLAIM,
# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
# OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
# OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# Except as contained in this notice, the names of the authors above
# shall not be used in advertising or otherwise to promote the sale,
# use or other dealings in this Software without prior written
# authorization from those authors.
########################################################################

# Bring in just the basics so we can bring in our local modules
import os
import sys
sys.path.insert (0, os.path.dirname (__file__) + '/../lib')
sys.path.insert (0, os.getcwd () + '/lib')

# Our local modules
from pidp8i import *
from simh   import *

# Other global Python modules
import glob
import subprocess
import shutil


#### GLOBALS AND CONSTANTS #############################################

# Path to the cross-compiler version of cc8.
cc8_cross = os.path.join (dirs.build, 'bin', 'cc8')

# Path to the CC8 sources
cc8_src = os.path.join (dirs.src, 'src', 'cc8')

# Name and extension of system packs.
_syspack = "v3d"
_sysext  = ".rk05"

# The OS/8 version of CC8's C sources are listed
# in dependency order, in case that later matters.
_modules = [ 'libc', 'c8', 'n8', 'p8' ]

# Example programs.
# Listed here in the order we expect to install them.
_examples = [ 'fib.c', 'calc.c', 'ps.c' ]


#### make_scratch ####################################################
# Imported from os8script.py
# Create a copy of the contents of image file using the python
# method to create a secure, named temp filename.
# The caller has split the image file name into a base path,
# and an extension which we use.
# After copying the source image, the file is closed and the name
# of the scratch file is returned.
def make_scratch (base_imagename, extension):
  try:
    src_image = open(base_imagename+extension, "rb")
  except IOError:
    print "Open of imagefile " + base_imagename + extension + " failed."
    return None
      
  try:
    dest_image = tempfile.NamedTemporaryFile(mode='w+b', \
                                             prefix=base_imagename+'-temp-', \
                                             suffix=extension, \
                                             delete=False)
  except:
    print "NamedTemporaryFile failed."
    
  destname = dest_image.name
  print "Temp file name is: " + destname

  try:
    shutil.copyfileobj(src_image, dest_image)
  except shutil.Error as e:
    print "Copy of imagefile " + base_imagename + extension + \
      " to scratch failed with error: " + str(e)
    return None
  except IOError as e:
    print "Copy of imagefile " + base_imagename + extension + \
      ", failed with IOError: " + \
      str(e)
    return None
  src_image.close()
  dest_image.close()
  return destname

  
#### cross_compile #####################################################
# Cross-compile a *.c file on the local machine to a *.s file we can
# send into the OS/8 instance.  The parameter should have no extension.

def cross_compile (module):
  inf  = module + '.c'
  outf = module + '.sb'

  if os.path.exists (outf) and \
      os.path.getmtime (inf) <= os.path.getmtime (outf):
    print outf + " up-to-date."
  else:
    print "Building " + outf + "..."
    try:
      rc = subprocess.call ([cc8_cross, inf])
    except subprocess.CalledProcessError as e:
      print "Run of " + cc8_cross + " " + inf + " failed with error: " + str(e)
    print "return call: " + str(rc)
    if rc == 0:
      print inf + " -> " + outf
    else:
      print "Failed to cross-compile the " + module.upper() + " module!"
      exit (1)


#### main ##############################################################

def main ():
  # We have to do much of the following from within the CC8 source dir
  # since the same source code is used for both versions of CC8, so the
  # compiler assumes a flat filesystem, hence no "include path", hence
  # all headers and such must be symlinked or copied into the same
  # directory as our primary inputs.
  os.chdir (os.path.join (cc8_src, 'os8'))

  # Cross-compile the OS/8 version of CC8's C sources to SABR.  These
  # files are listed in dependency order, in case that later matters.
  try:
    for m in _modules: cross_compile (m)
  except OSError as e:
    print "Cross-compilation steps failed: " + e.strerror + '!'
    exit (1)

  # Create the SIMH child instance and tell it where to send log output
  try:
    s = simh (dirs.build, True)
  except (RuntimeError) as e:
    print "Could not start simulator: " + e.message + '!'
    exit (1)
  s.set_logfile (os.fdopen (sys.stdout.fileno (), 'w', 0))

  # Zero core before beginning work.  See method comment for "whys".
  s.zero_core ()

  # Attach an empty DECtape to the simulator to hold our output.
  tape = os.path.join (dirs.os8mi, 'subsys', 'cc8.tu56')
  if os.path.exists (tape): os.remove (tape)
  s.send_cmd ("att dt0 " + tape)

  # Find and boot the bootable OS/8 disk.  Use the "patched" version
  # because that is what "make run" uses; we use that command to
  # inspect this script's work.
  rk = os.path.join (dirs.os8mo, _syspack + _sysext)
  if not os.path.isfile (rk):
    print "Could not find " + rk + "; OS/8 media not yet built?"
    exit (1)
  print "Using scratch copy of " + rk
  rk_scratch = make_scratch (os.path.join (dirs.os8mo, _syspack), _sysext)
  print "Booting " + rk_scratch + "..."
  s.send_cmd ("att rk0 " + rk_scratch)
  s.send_cmd ("boot rk0")

  # The OS/8 disk image we're running this against might not be freshly
  # generated by tools/mkos8.  It may have been used by a prior instance
  # of this script, messed with by the user, etc.  Therefore, try to
  # return it to as close to a pristine state as possible so that files
  # we create are added to the OS/8 directory list in a deterministic
  # order.  Otherwise, we may end up with a shuffled TU56 output file,
  # which Fossil would see as needing to be checked in again, even
  # though the file-for-file contents are no different.
  #
  # It is also possible that keeping these output files in a predictable
  # order is necessary for LOADER.SV to be deterministic, since some of
  # its inputs are *.RL files already on the working RK05 disk image.
  #
  # All of this is also why we only use wildcards in DEL commands, where
  # file ordering doesn't matter.
  #
  # sfiles are files on SYS: that get copied to DTA0:
  #
  # dfiles are files on DSK: that get copied to DTA0:  We use a list of
  # lists here to get around a low command line length limit in OS/8.
  #
  # tfiles are temporaries on DSK:, either left behind by this build
  # process or by prior action on the working RK05 disk.  We delete
  # these both before starting work and after in case we get Ctrl-C'd.
  #
  # We reverse the order of the files named because OS/8 appears to
  # process them right-to-left in a COPY command, and we want them to
  # land on DTA0: in the order given here in the source code.
  sfiles = ','.join([
    'SYS:{0}.SV'.format(f) for f in [ 'CC', 'CC1', 'CC2' ]
  ])

  up_examples = []
  for example in _examples:
    up_examples.append (example.upper())

  print
  dfiles = [ 
    ','.join(up_examples),
    ','.join([ 'HEADER.SB', 'LIBC.RL', 'CCR.BI' ]),
  ]
  tfiles = [
    ','.join([ '?8.SB', 'LIBC.SB', 'CC.SB' ]),
    ','.join([ '?8.RL', 'BLDCC8.BI', 'CC.C' ]),
  ]
  for fl in [ sfiles ] + dfiles + tfiles:
    s.os8_send_cmd ('\\.', 'DEL ' + fl)
  s.os8_squish ("SYS")
  s.os8_squish ("DSK")

  # Copy the SABR files produced above by the host-side cross-compiler
  # to the OS/8 environment's RK05 disk.
  for m in _modules:
    s.os8_send_file (m + '.sb')
    # Clean up after os8_send_file format conversion.
    os.remove(os.path.join (dirs.obj, m + ".sb.pt"))


  # Copy example programs in as well.
  #
  # We have to filter these files' content for the reasons given at the
  # top of cc8-to-os8.
  #
  # We don't let os8_send_file build the destination file name because
  # the source is a random-named temp file.
  tool = os.path.join (dirs.bin, 'cc8-to-os8')
  for example in _examples:
    src = '../examples/' + example
    ctf = tempfile.NamedTemporaryFile ()
    ctn = ctf.name
    os.system (tool + ' < ' + src + ' > ' + ctn)
    s.os8_send_file (ctn, os.path.basename (src).upper ())
    # Clean up after os8_send_file format conversion.
    ctpt = os.path.join (dirs.obj, os.path.basename(ctn) + ".pt")
    os.remove(ctpt)

  # Copy the remaining static OS/8 CC8 text files in.  We purposely do
  # not send init.h or libc.h because OS/8 CC8 doesn't process #include,
  # so it has those bits hard-coded into the compiler at the moment.
  for src in [ 'bldcc8.bi', 'ccr.bi', 'header.sb' ]:
    s.os8_send_file (src)
    # Clean up after os8_send_file format conversion.
    os.remove(os.path.join (dirs.obj, src + ".pt"))

  # Re-zero most of core.  See method comment for details.
  #
  # The SAVE command in BLDCC8.BI which we're trying to protect from
  # irreproducibility with this will ignore core areas left unzeroed.
  s.os8_zero_core ()

  # Build the OS/8 version of CC8 using the batch file we copied in.
  s.os8_send_cmd ('\\.', 'EXE BLDCC8.BI')

  # Save files in the ?files lists above to the cc8.tu56 image except
  # for those in tfiles, which we delete.
  s.os8_send_cmd ('\\.', 'ZERO DTA0:')
  for fl in [ sfiles ] + dfiles:
    s.os8_send_cmd ('\\.', 'COPY DTA0:<' + fl)
  for fl in tfiles:
    s.os8_send_cmd ('\\.', 'DEL ' + fl)

  # Detach the tape and exit the simulator.
  s.back_to_cmd ('\\.')
  s.send_cmd ('det dt0')
  s.send_cmd ('quit')
  print "Removing scratch system image: " + rk_scratch
  os.remove(rk_scratch)


if __name__ == "__main__": main()
