#!/usr/bin/python
# -*- coding: utf-8 -*-
########################################################################
# cc8-tu56-update - Rebuilds cc8.tu56 from source code.
#
# It is intended to be be called manually whenever a file in src/cc8/os8
# changes.  It is not called automatically from the top-level Makefile
# because not all end user systems will be able to run it, since our
# dependencies (host-side cc8 and SABR) are not always present.
#
# Copyright Â© 2017 by Warren Young.
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS LISTED ABOVE BE LIABLE FOR ANY CLAIM,
# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
# OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
# OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# Except as contained in this notice, the names of the authors above
# shall not be used in advertising or otherwise to promote the sale,
# use or other dealings in this Software without prior written
# authorization from those authors.
########################################################################

# Bring in just the basics so we can bring in our local modules
import os
import sys
sys.path.insert (0, os.path.dirname (__file__) + '/../lib')
sys.path.insert (0, os.getcwd () + '/lib')

# Our local modules
from pidp8i import *
from simh   import *

# Other global Python modules
import glob
import subprocess


#### GLOBALS AND CONSTANTS #############################################

# Path to the cross-compiler version of cc8.
cc8_cross = os.path.join (dirs.build, 'bin', 'cc8')

# Path to the CC8 sources
cc8_src = os.path.join (dirs.src, 'src', 'cc8')


#### cross_compile #####################################################
# Cross-compile a *.c file on the local machine to a *.s file we can
# send into the OS/8 instance.  The parameter should have no extension.

def cross_compile (module):
  inf  = module + '.c'
  outf = module + '.s'

  if os.path.exists (outf) and \
      os.path.getmtime (inf) <= os.path.getmtime (outf):
    print outf + " up-to-date."
  else:
    print "Building " + outf + "..."
    rc = subprocess.call ([cc8_cross, inf])
    if rc == 0:
      print inf + " -> " + outf
    else:
      print "Failed to cross-compile the " + module.upper() + " module!"
      exit (1)


#### main ##############################################################

def main ():
  # We have to do much of the following from within the CC8 source dir
  # since the same source code is used for both versions of CC8, so the
  # compiler assumes a flat filesystem, hence no "include path", hence
  # all headers and such must be symlinked or copied into the same
  # directory as our primary inputs.
  os.chdir (os.path.join (cc8_src, 'os8'))

  # Cross-compile the OS/8 version of CC8's C sources to SABR.  These
  # files are listed in dependency order, in case that later matters.
  modules = [ 'libc', 'c8', 'n8', 'p8' ]
  try:
    for m in modules: cross_compile (m)
  except OSError as e:
    print "Cross-compilation steps failed: " + e.strerror + '!'
    exit (1)

  # Create the SIMH child instance and tell it where to send log output
  try:
    s = simh (dirs.build, True)
  except (RuntimeError) as e:
    print "Could not start simulator: " + e.message + '!'
    exit (1)
  s.set_logfile (os.fdopen (sys.stdout.fileno (), 'w', 0))

  # Zero core before beginning.  SIMH's PDP-8 simulator doesn't do it,
  # on purpose, because the actual hardware did not do that.  SIMH does
  # not attempt to simulate the persistence of core memory by saving it
  # to disk between runs, but the developers are right: you cannot trust
  # the prior state of core before initializing it yourself.  Rather
  # than do that in some OS/8 specific way, we tell SIMH to do it.
  s.send_cmd ('de all 0')

  # Attach an empty DECtape to the simulator to hold our output.
  tape = os.path.join (dirs.os8mi, 'subsys', 'cc8.tu56')
  if os.path.exists (tape): os.remove (tape)
  s.send_cmd ("att dt0 " + tape)

  # Find and boot the bootable OS/8 disk.  Use the "patched" version
  # because that is what "make run" uses; we use that command to
  # inspect this script's work.
  rk = os.path.join (dirs.os8mo, 'os8v3d-patched.rk05')
  if not os.path.isfile (rk):
    print "Could not find " + rk + "; OS/8 media not yet built?"
    exit (1)
  print "Booting " + rk + "..."
  s.send_cmd ("att rk0 " + rk)
  s.send_cmd ("boot rk0")

  # Get rid of any C program sources that may happen to be laying around
  # on the RK05 disk image we start with so we don't copy any working
  # files created by hand to the cc8.tu56 tape with the wildcard below.
  s.os8_send_cmd ('\\.', 'DEL *.C')

  # Copy the SABR files produced above by the host-side cross-compiler
  # to the OS/8 environment's RK05 disk.
  for m in modules:
    source = m + '.s'
    dest = m.upper() + '.SB'
    s.os8_send_file (source, dest)

  # Copy example programs in as well.
  #
  # We have to filter these files' content for the reasons given at the
  # top of the filter's code.
  #
  # We don't let os8_send_file build the destination file name because
  # the source is a random-named temp file.
  tool = os.path.join (dirs.bin, 'cc8-to-os8')
  for src in glob.glob ('../examples/*.c'):
    ctf = tempfile.NamedTemporaryFile ()
    ctn = ctf.name
    os.system (tool + ' < ' + src + ' > ' + ctn)
    s.os8_send_file (ctn, os.path.basename (src).upper ())

  # Copy the remaining static OS/8 CC8 text files in.  We purposely do
  # not send init.h or libc.h because OS/8 CC8 doesn't process #include,
  # so it has those bits hard-coded into the compiler at the moment.
  for src in [ 'bldcc8.bi', 'cc.bi', 'header.sb' ]:
    s.os8_send_file (src)

  # Build the OS/8 version of CC8 using the batch file we copied in.
  s.os8_send_cmd ('\\.', 'EXE BLDCC8.BI')

  # Get rid of intermediary files on DSK: so the subsequent COPY
  # commands don't add them to the DECtape image.
  s.os8_send_cmd ('\\.', 'DEL ?8.RL,?8.SB,LIBC.SB')

  # Save all the remaining involved files to the cc8.tu56 tape, giving
  # DIR DTA0: output approximately like this:
  #
  # CC    .SV  27           CC1   .SV  41           CC2   .SV  41
  # FIB   .C    1           CALC  .C    5           BASIC .C   11
  # PS    .C    1           CC    .BI   1           HEADER.SB   6
  # LIBC  .RL  22       
  s.os8_send_cmd ('\\.', 'ZERO DTA0:')
  s.os8_send_cmd ('\\.', 'COPY DTA0:<SYS:CC.SV,SYS:CC1.SV,SYS:CC2.SV')
  s.os8_send_cmd ('\\.', 'COPY DTA0:<DSK:HEADER.SB,DSK:LIBC.RL,DSK:*.C,DSK:CC.BI')

  # Exit simulator nicely so that tape detaches cleanly
  s.back_to_cmd ('\\.')
  s.send_cmd ('quit')


if __name__ == "__main__": main()
