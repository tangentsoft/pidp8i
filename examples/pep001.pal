/ Project Euler Problem #1: Multiples of 3 and 5
/
/ ----------------------------------------------------------------------
/ If we list all the natural numbers below 10 that are multiples of
/ 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
/
/ Find the sum of all the multiples of 3 or 5 below 1000.
/ ----------------------------------------------------------------------
/ 
/ Solution by Warren Young of tangentsoft.com, 2016.11.29
////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////
/ DIY ASSEMBLER INSTRUCTIONS

/ Our assembler doesn't know the EAE instructions, so teach it
DVI=7407		/ integer divide .+1 into {AC:MQ}, answer in MQ
MUY=7405		/ integer multiply MQ by .+1, answer in {AC:MQ}

/ Combined microcoded instruction aliases
CLR=CLA CLL		/ clear both AC and L
MCM=CLA MQA		/ move MQ to AC
TCA=CMA IAC		/ two's complement the accumulator
XMA=MQA MQL		/ exchange MQ and AC
AC1=CLA IAC		/ set AC to 1


EJECT
//// MAIN //////////////////////////////////////////////////////////////

PAGE 1

	/ Try dividing 3 into CURR first
NEXT,	CLA
	TAD (3)
	JMS ISMOD0
	SNA		/ if ISMOD0 left AC = 0, CURR divided evenly by
	JMP SKIP5	/ 3, so skip 5 lest we count multiples of 15 2x

	/ That didn't work out, so try dividing 5 into it
	CLA
	TAD (5)
	JMS ISMOD0

	/ increment CURR
SKIP5,	CLA		
	TAD CURR
	IAC
	DCA CURR

	/ iterate unless CURR == MAX
	TAD CURR
	TCA
	TAD MAX
	SZA
	JMP NEXT

	/ Finished main loop. Write answer to terminal in octal.
DONE,	CLA
	TAD TOTAL
	HLT		/ wait for user to verify answer in binary
	JMS DECPRT	/ print on console in decimal (ASCII)
	JMP 7600	/ re-enter OS/8

/ Constants
	DECIMAL
MAX,	9		/ check natural numbers CURR to MAX; must be < 4096!
	OCTAL

/ Variables
CURR,	3		/ current number we're checking; skip 1 & 2
QUOTNT,	0		/ quotient calculated in division step
TOTAL,	0		/ the answer, in binary form; see also ANSBUF



EJECT
//// ISMOD0 ////////////////////////////////////////////////////////////
/ If passed AC divides evenly into CURR (in C-speak, CURR % AC == 0)
/ add CURR to TOTAL and return 0 in AC.  Else, return nonzero in AC and
/ leave TOTAL untouched.

ISMOD0,	0
	/ Move AC to operand word after DVI instruction that uses it
	DCA DIVISOR

	/ Divide CURR by it
	TAD CURR	/ load CURR into just-cleared AC
	MQL		/ move it to MQ, clearing AC
	DVI		/ divide DIVISOR into {AC:MQ}, quotient into MQ
DIVISOR,0		/ copy of divisor which ISMOD0 got as AC

	/ Now multiply it back out
	TAD DIVISOR	/ AC should still be zero here
	DCA MCAND	/ save copy of DIVISOR as multiplicand
	MUY		/ which we multiply by MQ, still holding quotient
MCAND,	0

	/ Moment of truth: did that pair of operations yield CURR?
	MCM		/ could do MQA because AC must be 0 with CURR <
			/ 2^12, but it costs nothing to be safe here
	TCA		/ flip AC's sign
	TAD CURR	/ and add to CURR, subtracting product from it
	SZA		/ skip early return if AC is 0
	JMP I ISMOD0
	TAD CURR	/ AC is 0, so we can load CURR directly
	TAD TOTAL
	DCA TOTAL
	JMP I ISMOD0


EJECT
//// DECPRT ////////////////////////////////////////////////////////////
// Decimal number printer; see examples/routines/decprt.pal

DECPRT,	0
	DCA VALUE	/SAVE INPUT
	DCA DIGIT	/CLEAR
	TAD CNTRZA
	DCA CNTRZB	/SET COUNTER TO FOUR
	TAD ADDRZA
	DCA ARROW	/SET TABLE POINTER
	SKP
	DCA VALUE	/SAVE
	CLL
	TAD VALUE
ARROW,	TAD TENPWR	/SUBTRACT POWER OF TEN
	SZL
	ISZ DIGIT	/DEVELOP BCD DIGIT
	SZL
	JMP ARROW-3	/LOOP
	CLA		/HAVE BCD DIGIT
	TAD DIGIT	/GET DIGIT
	TAD K260	/MAKE IT ASCII
	TSF		/OR TAD DIGIT
	JMP .-1		/JMS TDIGIT(SEE 8-19-U)
	TLS		/TYPE DIGIT
	CLA
	DCA DIGIT	/CLEAR
	ISZ ARROW	/UPDATE POINTER
	ISZ CNTRZB	/DONE ALL FOUR?
	JMP ARROW-1	/NO: CONTINUE
	JMP I DECPRT	/YES: EXIT
ADDRZA,	TAD TENPWR
CNTRZA,	-4
TENPWR,	-1750		/ONE THOUSAND
	-0144		/ONE HUNDRED
	-0012		/TEN
	-0001		/ONE
K260,	260
VALUE,	0
DIGIT,	0
CNTRZB,	0


//// END ///////////////////////////////////////////////////////////////
$
