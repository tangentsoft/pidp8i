/ Project Euler Problem #1, Multiples of 3 and 5:
/
/   If we list all the natural numbers below 10 that are multiples of
/   3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
/   Find the sum of all the multiples of 3 or 5 below 1000.
/ 
/ Solution by Warren Young of tangentsoft.com, 2016.11.30
////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////
/ DIY ASSEMBLER INSTRUCTIONS

/ Our assembler doesn't know the EAE instructions, so teach it
DVI=7407		/ integer divide .+1 into {AC:MQ}, answer in MQ

/ Combined microcoded instruction aliases
CLR=CLA CLL		/ clear both AC and L
TCA=CMA IAC		/ two's complement the accumulator


//// MAIN //////////////////////////////////////////////////////////////
/ Program entry point.   We purposely reinitialize global variables and
/ processor state in case we're restarting this program in-core.

PAGE 1
MAIN,	CLR
	TAD (3)
	DCA CURR	/ start with 3, because we know 1 & 2 can't work
	DCA TOTAL	/ reset total to 0
	TLS		/ send null to terminal to get flags set right
	TAD (ANSWER)	/ write "ANSWER: " to the terminal
	JMS PRINTS
	JMP MLCORE
CURR,	0		/ current number we're checking
TOTAL,	0		/ the answer so far; at the end, printed out

/ Constants
	DECIMAL
MAX,	999		/ check natural numbers CURR to MAX; must be < 2048!
STMAX,	1024		/ subtotal max; avoids overflow of 12-bit signed int

	OCTAL
CRLF,	15;12;0		/ ASCII character values; don't forget trailing 0!
PLUS,	40;53;40;0
ANSWER,	101;116;123;127;105;122;72;40;0


//// MLCORE ////////////////////////////////////////////////////////////
/ The core of the main loop.  MAIN just inits the globals and calls us.

	/ Try dividing 3 into CURR first
MLCORE,	CLR
	TAD (3)
	JMS ISMOD0
	SNA		/ if ISMOD0 left AC = 0, CURR divided evenly by
	JMP NXITER	/ 3, so skip 5 lest we count multiples of 15 2x

	/ That didn't work out, so try dividing 5 into it
	CLA
	TAD (5)
	JMS ISMOD0

	/ Loop cleanup
NXITER,	CLA		
	TAD CURR
	TCA
	TAD MAX		/ = 0 if CURR == MAX
	SNA		/ if so, leave calculation loop
	JMP MLDONE

	CLR		/ CURR still < MAX, so increment CURR
	TAD CURR	
	IAC
	DCA CURR

	TAD TOTAL	/ if TOTAL is getting too big, print...
	TCA		/ a subtotal and zero TOTAL so we don't...
	TAD STMAX	/ overflow the 12-bit limit
	SZL
	JMP MLCORE	/ STMAX - TOTAL > 0 so re-enter loop core
	JMS SHOTOT	/ exceeded threshold, so display subtotal and " + "
	CLA
	DCA TOTAL	/ take advantage of free zero
	TAD (PLUS)
	JMS PRINTS
	JMP MLCORE	

	/ Calculation complete.  Show answer and exit gracefully.
MLDONE,	JMS SHOTOT
	CLA
	TAD (CRLF)
	JMS PRINTS
	JMP ENDG


//// ISMOD0 ////////////////////////////////////////////////////////////
/ If passed AC divides evenly into CURR (in C-speak, CURR % AC == 0)
/ add CURR to TOTAL and return 0 in AC.  Else, return nonzero in AC and
/ leave TOTAL untouched.

ISMOD0,	0
	/ Divide CURR by DIVISOR, passed as AC
	DCA DIVISOR
	TAD CURR	/ load CURR into just-cleared AC
	MQL DVI		/ move CURR to MQ, divide by DIVISOR...
DIVISOR,0		/ ...quotient in MQ, remainder in AC
	SZA
	JMP I ISMOD0	/ remainder nonzero, so leave early

	/ Division left AC empty, so CURR divides evenly by DIVISOR!
	TAD CURR	/ don't need to clear AC; prior test says AC == 0
	TAD TOTAL
	DCA TOTAL
	JMP I ISMOD0


//// SHOTOT ////////////////////////////////////////////////////////////
/ Write TOTAL to terminal in decimal, nothing following.

SHOTOT,0
	CLR
	TAD TOTAL
	JMS DECPRT	/ print answer on console, in decimal
	TSF		/ wait for terminal to be ready again
	JMP .-1

	JMP I SHOTOT	/ and done



//// PRINTS ////////////////////////////////////////////////////////////

PRINTS,0
	DCA SADDR	/ save AC as string address
PSNEXT,	TAD I SADDR	/ load next character
	SNA
	JMP I PRINTS	/ found the null terminator; leave

	TSF		/ wait for terminal to be ready
	JMP .-1
	TLS		/ write character to the terminal

	CLA		/ increment string address pointer
	TAD SADDR
	IAC
	DCA SADDR
		
	JMP PSNEXT	/ look at next character
SADDR,	0


//// ENDG //////////////////////////////////////////////////////////////
// End program gracefully, either re-entering OS/8 if we can see that
// its entry point looks sane, or halting with the answer in AC so the
// user can see the answer on the front panel.

ENDG,	CLA
	TAD OS8ENT
	TCA
	TAD OS8INS1
	SNA
	JMP 7600	/ re-enter OS/8
	CLR
	TAD TOTAL
	HLT		/ not running under OS/8, so halt
OS8ENT,	7600		/ OS/8 entry point
OS8INS1,4207		/ first instruction at that entry point


//// DECPRT ////////////////////////////////////////////////////////////
// Decimal number printer; see examples/routines/decprt.pal

PAGE 2
DECPRT,	0
	DCA VALUE	/SAVE INPUT
	DCA DIGIT	/CLEAR
	TAD CNTRZA
	DCA CNTRZB	/SET COUNTER TO FOUR
	TAD ADDRZA
	DCA ARROW	/SET TABLE POINTER
	SKP
	DCA VALUE	/SAVE
	CLL
	TAD VALUE
ARROW,	TAD TENPWR	/SUBTRACT POWER OF TEN
	SZL
	ISZ DIGIT	/DEVELOP BCD DIGIT
	SZL
	JMP ARROW-3	/LOOP
	CLA		/HAVE BCD DIGIT
	TAD DIGIT	/GET DIGIT
	TAD K260	/MAKE IT ASCII
	TSF		/OR TAD DIGIT
	JMP .-1		/JMS TDIGIT(SEE 8-19-U)
	TLS		/TYPE DIGIT
	CLA
	DCA DIGIT	/CLEAR
	ISZ ARROW	/UPDATE POINTER
	ISZ CNTRZB	/DONE ALL FOUR?
	JMP ARROW-1	/NO: CONTINUE
	JMP I DECPRT	/YES: EXIT
ADDRZA,	TAD TENPWR
CNTRZA,	-4
TENPWR,	-1750		/ONE THOUSAND
	-0144		/ONE HUNDRED
	-0012		/TEN
	-0001		/ONE
K260,	260
VALUE,	0
DIGIT,	0
CNTRZB,	0


//// END ///////////////////////////////////////////////////////////////
/ Assembler-generated constants will appear below this in the list file
$
