#!/usr/bin/python
# -*- coding: utf-8 -*-
########################################################################
# mkos8 - Build bin/os8v3d-*.rk05 from media/*/*.tu56 by scripting
#    commands to SIMH and OS/8.
#
# Copyright Â© 2017 by Jonathan Trites, William Cattey, and Warren Young.
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS LISTED ABOVE BE LIABLE FOR ANY CLAIM,
# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
# OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
# OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# Except as contained in this notice, the names of the authors above
# shall not be used in advertising or otherwise to promote the sale,
# use or other dealings in this Software without prior written
# authorization from those authors.
########################################################################

# Bring in just the basics so we can bring in our local modules
import os
import sys
sys.path.insert (0, os.path.dirname (__file__) + '/../lib')

# Our local modules
from mkos8 import *

# 3rd party dependencies
import pkg_resources
import pexpect

# Remaining Python core modules
from shutil import copyfile
import subprocess
import time


#### globals and constants #############################################

child = None

# Flag set when -v is *not* given.  Causes make_*() and the functions
# called thereby to print progress messages to the console since SIMH
# and OS/8 output is not being sent there to clue the user into the
# script's progress.
progmsg = True

# kludgy flag to add more verbose debug output.
debug = False

_bin_rk05 = "os8v3d-bin.rk05"
_src_rk05 = "os8v3d-src.rk05"


#### simh_send #########################################################
# Wait for a SIMH command prompt and then send the given line

def simh_send (send_line):
  global child

  child.expect("sim> $")
  child.sendline(send_line)


#### os8_kbd_delay #####################################################
# Artificially delay the media generation process to account for the
# fact that OS/8 lacks a modern multi-character keyboard input buffer.
# It is unsafe to send text faster than a contemporary terminal could.
#
# The constant is expanded to show that it comes from the 2400 bps of
# the VT05s used by some well-heeled PDP-8 users divided by 7-bit ASCII
# plus necessary start, stop, and parity bits.  The constant is inverted
# to get seconds per character instead of characters per second.  OS/8
# must be at least this fast, being contemporary with the VT05.
#
# You might think to try and speed this up by increasing the 2400 bps
# value below.  For one thing, the 9600 bps VT52 was probably used with
# some later OS/8 systems.  Also, the higher IPS rate of our simulated
# PDP-8 must help here.  However, if you actually time doing so, it
# doesn't help, presumably because other I/O overheads (e.g. the TU56
# reading time) swamp any improvement you can get here.

_kbd_delay = 1 / (2400 / (7 + 1 + 1 + 1))
def os8_kbd_delay():
  time.sleep(_kbd_delay)


#### os8_send_line #####################################################
# Core of os8_pmt_send.  Also used by code that needs to send text
# "blind" to OS/8, without expecting a prompt, as when driving EDIT.

def os8_send_line (send_line):
  global child

  for i in xrange(0, len (send_line)):
    child.send (send_line[i])
    os8_kbd_delay ()
  child.send ("\r")


#### os8_pmt_send ######################################################
# Wait for an OS/8 command prompt running within SIMH, then send the
# given line.
#
# The prompt string is passed in because OS/8 has several different
# prompt types.

def os8_pmt_send (prompt, send_line):
  global child

  child.expect ("\n%s$" % prompt)
  os8_send_line (send_line)


#### os8_send_ctrl #####################################################
# Send a control character to OS/8 corresponding to the ASCII letter
# given.  We precede it with the OS/8 keyboard delay, since we're
# probably following a call to os8_send_line or os8_pmt_send.

def os8_send_ctrl (char):
  global child
  os8_kbd_delay ()
  child.send (chr (ord (char[0].upper ()) - ord ('@')))


#### os8_restart #######################################################
# Called while in the SIMH command prompt, this restarts OS/8.
#
# This one-line function exists to abstract the method we use and to
# document the reason we do it this way.
#
# Currently we do this by calling the OS/8 command entry point, which
# has the virtue that it forces another . prompt, which keeps the send/
# expect sequencing simple when switching between OS/8 and SIMH command 
# modes.
#
# That is why we don't use "cont" here instead: it requires that the
# caller always be aware of when the . prompt went out; complicated.
#
# Another simple alternative is "boot rk0", which actually benchmarks a
# smidge faster here.  We choose this method instead because we expect
# that some of our callers will want to do several different things in
# a single OS/8 session, which rebooting would screw up.

def os8_restart ():
  simh_send("go 7600")


#### back_to_simh ######################################################
# Go back to SIMH when the passed prompt string is encountered

def back_to_simh (prompt):
  global child

  child.expect("\n%s$" % prompt)
  os8_kbd_delay()
  child.sendcontrol('e')


#### check_exists ######################################################
# Check existence of all files needed

def check_exists (image_copyins):
  global child

  # Confirm necessary media images exist.
  for copyin in image_copyins:
    image = copyin[1]
    image_path = dirs.media + image
    if (not os.path.isfile(image_path)):
        print "Required file: " + image_path + " not found."
        simh_send("q")
        child.expect(pexpect.EOF)
        exit (-1)
    # else: print "Found " + image_path

   
#### Data Structures ##################################################
#
# The make procedures use helper procedures
# to confirm that the relevant input image file exists and
# to perform the file copies.
#
# A data structure called "image copyin"
#    describes the image file pathname relative to an implied root,
#    provides a message string when the action is run,
#    names a default destination device for whole image content copies,
#    offers an optional array of specific file copy actions.
#
# FUTURE: Parse source path for ".tu56" vs. ".rk05" for more general use.
# Currently all code assumes a copyin comes from a DECtape image.
#
# Example: We Install all files for ADVENT, the Adventure game:
#
# advent_copyin = ['RKB0:', 'subsys/advent.tu56',  "Installing ADVENT...", None]
#
# A DECtape device is chosen for attachment in SIMH and
# a 'COPY *.*' command is filled in with the Destination device, and the chosen DECtape.
#
# A data structer called "file copyin"
#     provides override destination to allow renames or varied destinations.
#     names individual files within a copyin to use
#
# Example:  To copy the C compiler we want all .SV files on SYS
#           but everything else to RKB0:
#           (Note the useful /V option to invert the match.)
#
# cc8_sv_file_copyin   = ['SYS:', '*.SV']
# cc8_rest_file_copyin = ['RKB0:', '*.SV/V']
#
# A 'COPY' command is filled in with the override destination and
# The file spec is used with the chosen dectape instead of "*.*"
#

#### copyin_pair #######################################################
# Copy two images into two destinations with two messages
#
# Assumes our context is "in simh".
# Assumes dt0 and dt1 are free.
# Assumes rk0 is the boot device
# Detaches dt0 and dt1 after using them.
# copyin0 mounts on dt0.  copyin1 mounts on dt1.
# Either copyin or both can be None

def copyin_pair (copyin0, copyin1):
  if debug:
    if copyin0:
      print "Copying: " + copyin0[1] + " to: " + copyin0[0] + "from dt0"
    else: print "copyin0 is empty."
    if copyin1:
      print "Copying: " + copyin1[1] + " to: " + copyin1[0] + "from dt1"
    else: print "copyin1 is empty."
    
  if not copyin0 and not copyin1: return   # Nothing to do.

  # The order of events here is a bit funky because we want
  # to use both DECtape drives but also
  # switch between SIMH and OS/8 as infrequently as possible.

  if copyin0: simh_send("attach -r dt0 " + dirs.media + copyin0[1])
  if copyin1: simh_send("attach -r dt1 " + dirs.media + copyin1[1])

  os8_restart()

  if copyin0:
    if progmsg: print copyin0[2]
    if copyin0[3]:                    # We have specific files to do.
      for file_copyin in copyin0[3]:
        os8_pmt_send("\.", "COPY " + file_copyin[0] + "<DTA0:" + file_copyin[1])
    else:
      os8_pmt_send("\.", "COPY " + copyin0[0] + "<DTA0:*.*")

  if copyin1:
    if progmsg: print copyin1[2]
    if copyin1[3]:                    # We have specific files to do.
      for file_copyin in copyin1[3]:
        os8_pmt_send("\.", "COPY " + file_copyin[0] + "<DTA1:" + file_copyin[1])
    else:
      os8_pmt_send("\.", "COPY " + copyin1[0] + "<DTA1:*.*")

  back_to_simh("\.")

  if copyin0: simh_send("detach dt0")
  if copyin1: simh_send("detach dt1")


#### do_all_copyins ####################################################

def do_all_copyins (copyins):
  pair_idx = 0
  pair_ct = int(len(copyins) / 2)
  while pair_idx < pair_ct:
    copyin_pair(copyins[pair_idx * 2], copyins[pair_idx * 2 + 1])
    pair_idx += 1
  if pair_ct * 2 < len(copyins):
    copyin_pair(copyins[len(copyins) - 1], None)

  
#### make_bin ##########################################################
# Top-level driver for the "make binary OS/8 RK05 disk image" process.
#
# If there is already an RK05 binary destination image, moves it aside
# to a ".save" instance, overwriting the previous .save if it exists.
#
# One of the input images is used as a bootable DECtape.
# That DECtape gets written on.
# It needs stuff from tape #2
# So the first two DECtapes
# are treated separately and specially.
# All the other DECtape images used are read only.

def make_bin (args):

  ro_boot_tape =       "al-4711c-ba-os8-v3d-1.1978.tu56"
  ro_boot_tape_path =  dirs.media + ro_boot_tape
  driver_tape =        "al-4712c-ba-os8-v3d-2.1978.tu56"
  driver_tape_path =   dirs.media + driver_tape
  local_tape =         "local.tu56"
  local_tape_path =    dirs.media + local_tape
  
  boot_dt_path = dirs.media + "bootable-al-4711-c-ba-os8-v3d-1.1978.tu56"

  special_bin_copyins = [
    ["", ro_boot_tape,  "", None],
    ['RKA0:', driver_tape, "Device Drivers...", None],
  ]

  music_copyin  = ['RKB0:', 'subsys/music.tu56',
                    "Copying in Music score files and source code...", None]

  ba_copyin     = ['RKB0:', 'subsys/ba.tu56',
                   "Installing *.BA BASIC games and demos...", None]

  cc8_files     = [['SYS:', '*.SV'], ['RKB0:', '*.SV/V']]

  cc8_copyin    = ['RKB0:', 'subsys/cc8.tu56',
                   "Installing Ian Schofield's CC8 compiler...", cc8_files]

  k12_copyin    = ['RKA0:', 'subsys/k12.tu56',
                   "Installing Kermit-12...", None]

  focal69_files  = [['RKB0:', 'FOCAL.BN'], ['RKB0:','4WORD.BN'],
                    ['RKB0:', '4KVT.BN'], ['RKB0:', '8KVT.BN'],
                    ['RKB0:', '8KNOVT.BN']
  ] 
  focal69_copyin = ['RKA0:', 'subsys/focal69.tu56',
                    "Installing FOCAL 69...", focal69_files]

  uwfocal_files  = [['SYS:', 'UWF16K.SV']]
  
  uwfocal_copyin = ['RKA0:', 'subsys/uwfocal-v4e-2.tu56',
                    "Installing U/W FOCAL...", uwfocal_files]

  advent_copyin = ['RKB0:', 'subsys/advent.tu56',
                   "Installing ADVENT...", None]

  bin_copyins = [
    ['RKA0:', "al-4761c-ba-os8-v3d-ext.1978.tu56",
     "Copying in OS/8 V3D extensions...", None],
    ['RKA0:', "al-4549d-ba-fr4-v3d-1.1978.tu56",
     "Copying in FORTRAN IV tape 1 of 2...", None],
    ['RKA0:', "al-5596d-ba-fr4-v3d-2.1978.tu56",
     "Copying in FORTRAN IV tape 2 of 2...", None],
    ['RKA0:', "al-5642a-ba-macrel-linker.1978.tu56",
     "Installing MACREL...", None]
    ]

  local_files = []
  local_stat_str = "Performing copyins from " + local_tape + ":\n"

  # Case Conversion scripts from local.tu56.
  local_stat_str += "    Case Conversion batch scripts.\n"
  local_files.append(['RKA0:', '?CSYS.BI'])
  local_files.append(['RKA0:', '?CBAS.BI'])

  if not args.disable_chess:
    local_stat_str += "    CHESS.SV binary and CHESS.TX documentation...\n"
    local_files.append(['RKA0:', 'CHESS.*'])

  if args.enable_vtedit:
    local_stat_str += "    TECO VTEDIT setup...\n"
    local_files.append(['RKA0:', 'VTEDIT.*'])
    local_files.append(['RKA0:', 'TECO.IN'])

  if not args.disable_dcp:
    # Should we also install DCP.WU on RKB0:?
    local_stat_str += "    DCP Disassembler: DCP24.SV, and DCP16.SV as DCP.SV.\n"
    local_files.append(['RKA0:', 'DCP24.SV'])
    local_files.append(['RKA0:DCP.SV', 'DCP16.SV'])

  if args.enable_music:        bin_copyins.append(music_copyin)
  if not args.disable_ba:      bin_copyins.append(ba_copyin)
  if not args.disable_cc8:     bin_copyins.append(cc8_copyin)
  if not args.disable_k12:     bin_copyins.append(k12_copyin)
  if not args.disable_advent:  bin_copyins.append(advent_copyin)

  if local_files != []:
    local_copyins = ['RKA0:', local_tape, local_stat_str, local_files]
    bin_copyins.append(local_copyins)

  if args.enable_focal69 and not args.disable_focal:
    bin_copyins.append(focal69_copyin)
  if not args.disable_uwfocal and not args.disable_focal:
    bin_copyins.append(uwfocal_copyin)

  check_exists(special_bin_copyins)
  check_exists(bin_copyins)

  print "Generating " + _bin_rk05 + " from " + str(len(bin_copyins) + 2) + \
        " source tapes..."

  image_path = dirs.os8 + _bin_rk05
  if os.path.isfile(image_path):
    save_path = dirs.media + _bin_rk05 + ".save"
    print "Pre-existing " + _bin_rk05 + " found.  Saving as " + _bin_rk05 + ".save"
    if os.path.isfile(save_path):
      print "Overwriting old " + _bin_rk05 + ".save"
      os.remove(save_path)
    os.rename(image_path, save_path)
  
  global progmsg
  if progmsg: print "Building initial OS/8 system..."
  
  if progmsg: print "Making a writeable copy of boot DECtape..."
  copyfile(ro_boot_tape_path, boot_dt_path)
  
  simh_send("attach rk0 " + image_path)
  simh_send("attach dt0 " + boot_dt_path)
  simh_send("attach -r dt1 " + driver_tape_path)

  if progmsg: print "Performing config with BUILD..."
  simh_send("boot dt0")
  os8_pmt_send("\.", "SET SYS NO INIT")   # initially, don't run INIT.CM 
  os8_pmt_send("\.", "RUN SYS BUILD")
  os8_pmt_send("\$", "LOAD DTA1:RK8ESY.BN")
  os8_pmt_send("\$", "LOAD DTA1:PT8E.BN")
  os8_pmt_send("\$", "DELETE SYS")
  os8_pmt_send("\$", "SYSTEM RK8E")
  os8_pmt_send("\$", "DELETE RXA1")
  os8_pmt_send("\$", "INSERT PT8E,PTR")
  os8_pmt_send("\$", "INSERT PT8E,PTP")
  os8_pmt_send("\$", "DELETE RKA0")
  os8_pmt_send("\$", "DELETE RKB0")
  os8_pmt_send("\$", "INSERT RK8E,RKA0,RKB0")
  os8_pmt_send("\$", "INSERT RK05,RKA2,RKB2")
  os8_pmt_send("\$", "DELETE DTA0")
  os8_pmt_send("\$", "INSERT TC,DTA0")
  os8_pmt_send("\$", "DSK RK8E:RKB0")
  os8_pmt_send("\$", "PRINT")
  os8_pmt_send("\$", "BOOT")
  os8_pmt_send("WRITE ZERO DIRECT\?", "Y")
  os8_pmt_send("\.", "SAVE SYS BUILD")
  back_to_simh("\.")
  
  if progmsg: print "Copying OS/8 system files from TU56 source to RK05 image..."
  if progmsg: print "Copying in system tape 1 of 2..."
  simh_send("boot dt0")
  os8_pmt_send("\.", "COPY RKA0:<DTA0:*.*")

  # There are not enough directory entries to put everything
  # Including all device drivers on the running packs.
  # So we DONT copy in the device drivers, nor TDINIT.SV,
  # nor the two TD8E-based DECtape system area files.
  # CCL.PA and KL8E.PA will be on the source disk.
  # However DECtape 2 has HELP.HL and .RL files that ARE needed.
  # if progmsg: print "Copying in system tape 2 of 2..."
  # os8_pmt_send("\.", "COPY RKA0:<DTA1:*.*")

  if progmsg: print "Copying in Fortran II libraries and help files from tape 2 of 2"
  os8_pmt_send("\.", "COPY RKA0:<DTA1:*.RL")
  os8_pmt_send("\.", "COPY RKA0:<DTA1:*.HL")
  os8_pmt_send("\.", "ZERO RKB0:")      # must precede subsys/* copies

  back_to_simh("\.")
  
  if progmsg: print "Deleting bootable copy of DECtape image and"
  if progmsg: print "rebooting into freshly-built RK05 OS/8 system..."
  simh_send("detach dt0")
  simh_send("detach dt1")
  simh_send("boot rk0")     # must do: boot media just went away
  back_to_simh("\.")
  os.remove(boot_dt_path)

  if progmsg: print "Performing remaining copies/installs..."
  do_all_copyins(bin_copyins)

  # Any further initialization of installed software is done here.
  simh_send("boot rk0")

  if not args.disable_crt:
    # NO SCOPE mode is the default on distribution tapes.
    if progmsg: print "Configuring scope-style rubout processing..."
    os8_pmt_send("\.", "SET TTY SCOPE")
  
  # Make sure Scripts are included in local_files array!
  # Or this will fail.
  if not args.disable_lcmod:
    if progmsg: print "Patching OS/8 to upcase commands only; SIMH is set not to auto-upcase."
    os8_pmt_send("\.", "SUBMIT SYS:LCSYS.BI")
    if progmsg: print "Patching OS/8 BASIC to cope with lower case input"
    os8_pmt_send("\.", "SUBMIT SYS:LCBAS.BI")

  # Create a banner message and optionally set it to show on boot.
  # This message is always upcased, even if you do this before calling
  # LCSYS.BI.  Is it a limitation of EDIT?
  if progmsg: print "Setting INIT message..."
  os8_pmt_send("\.", "CREATE INIT.TX")
  os8_pmt_send("#", "A")        # append text to file
  os8_send_line("Hello, world!")
  os8_send_ctrl('L')            # return to EDIT command mode
  os8_pmt_send("#", "E")        # save and exit
  os8_pmt_send("\.", "CREATE INIT.CM")
  os8_pmt_send("#", "A")
  os8_send_line("TYPE INIT.TX")
  os8_send_ctrl('L')
  os8_pmt_send("#", "E")
  if not args.disable_init:
    # Set the message to display only if the user did not suppress it.
    # We do it this way so the user can turn it on later without
    # rebuilding their OS/8 media.
    os8_pmt_send("\.", "SET SYS INIT")

  # Finish up
  if progmsg: print "Cleaning up..."
  back_to_simh("\.")
  simh_send("detach rk0")



#### make_src ##########################################################
# Source-disk version of make_bin() above.

def make_src (args):
  src_copyins = [
    ["RKA1:", "al-4691c-sa-os8-v3d-1.1978.tu56", "...part 1 of 7...", None],
    ["RKA1:", "al-4692c-sa-os8-v3d-2.1978.tu56", "...part 2 of 7...", None],
    ["RKA1:", "al-4693d-sa-os8-v3d-3.1978.tu56", "...part 3 of 7...", None],
    ["RKA1:", "al-4694c-sa-os8-v3d-4.1978.tu56", "...part 4 of 7...", None],
    ["RKB1:", "al-4695c-sa-os8-v3d-5.1978.tu56", "...part 5 of 7...", None],
    ["RKB1:", "al-4696c-sa-os8-v3d-6.1978.tu56", "...part 6 of 7...", None],
    ["RKB1:", "al-4697c-sa-os8-v3d-7.1978.tu56", "...part 7 of 7...", None],
    ["RKB1:", "al-4759c-sa-os8-ext-1.1978.tu56",
     "extensions part 1 of 3...", None],
    ["RKB1:", "al-4760c-sa-os8-ext-2.1978.tu56", "...part 2 of 3...", None],
    ["RKA1:", "al-5586c-sa-os8-ext-3.1978.tu56", "...part 3 of 3...", None],
  ]
  
  check_exists(src_copyins)

  print "Generating " + _src_rk05 + " from " + str(len(src_copyins)) + \
        " source tapes..."

  bin_path = dirs.os8 + _bin_rk05
  if (not os.path.isfile(bin_path)):
    print _bin_rk05 + " is needed to build src.  Creating..."
    make_bin(args)

  src_path = dirs.os8 + _src_rk05
  if os.path.isfile(src_path):
    save_path = src_path + ".save"
    print "Pre-existing " + _src_rk05 + " found.  Saving as " + _src_rk05 + ".save"
    if os.path.isfile(save_path):
      print "Overwriting old " + _src_rk05 + ".save"
      os.remove(save_path)
    os.rename(src_path, save_path)
    
  if progmsg: print "Copying OS/8 source distribution:"
  simh_send("attach rk0 " + bin_path)
  simh_send("attach rk1 " + src_path)

  simh_send("boot rk0")
  
  os8_pmt_send("\.", "ZERO RKA1:")
  os8_pmt_send("\.", "ZERO RKB1:")

  back_to_simh("\.")

  do_all_copyins(src_copyins)

  if progmsg: print "Cleaning up..."
  simh_send("detach rk0")
  simh_send("detach rk1")


#### main ##############################################################
# Program entry point.  Parses the command line and drives the above.

def main ():
  # Parse the command line
  allowed_acts = ["all", "bin", "src"]
  ap = argparser.ArgParser (allowed_acts)
  global progmsg
  progmsg = not ap.args.verbose

  # Initialize our acts dict.
  acts = {}
  first_act = None
  for this in allowed_acts:
    acts[this] = False

  for act in ap.args.what:
    if act not in allowed_acts:
      print "Invalid act: " + act + " ignored."
      continue

    if first_act == None: first_act = act

    if act == "all":
      for this in allowed_acts:
        acts[this] = True
      break
    acts[act] = True
  
  # Start the simulator instance we'll use to build the media images
  global child
  child = pexpect.spawn(dirs.build + '/bin/pidp8i-sim')

  # Turn off pexpect's default inter-send() delay.  We add our own as
  # necessary.  The conditional is due to an API change between 3 and 4.
  pev4 = (pkg_resources.get_distribution("pexpect").parsed_version >
          pkg_resources.parse_version("4.0"))
  child.delaybeforesend = None if pev4 else 0

  # Log SIMH and OS/8 output to a file by default, but send it to the
  # console instead of the progress messages if -v was given using the
  # trick from https://stackoverflow.com/questions/21239338
  child.logfile = open(dirs.log + 'mkos8-' + first_act + '.log', 'w') \
    if progmsg else os.fdopen(sys.stdout.fileno(), 'w', 0)

  if acts["bin"]: make_bin (ap.args)
  if acts["src"]: make_src (ap.args)
  
  simh_send("q")
  child.expect(pexpect.EOF)
  if progmsg: print "Done!"


if __name__ == "__main__":
    main()
