#!/usr/bin/python
# -*- coding: utf-8 -*-
########################################################################
# mkos8 - Build bin/os8v3d-*.rk05 from media/*/*.tu56 by scripting
#    commands to SIMH and OS/8.
#
# Copyright Â© 2017 by Jonathan Trites, William Cattey, and Warren Young.
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS LISTED ABOVE BE LIABLE FOR ANY CLAIM,
# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
# OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
# OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# Except as contained in this notice, the names of the authors above
# shall not be used in advertising or otherwise to promote the sale,
# use or other dealings in this Software without prior written
# authorization from those authors.
########################################################################

# Bring in just the basics so we can bring in our local modules
import os
import sys
sys.path.insert (0, os.path.dirname (__file__) + '/../lib')
sys.path.insert (0, os.getcwd () + '/lib')

# Remaining Python core modules
import re
from string import Template
import shutil
import subprocess

# Our local modules
from mkos8 import *
from pidp8i import *
from simh import *


#### globals and constants #############################################

# Flag set when -v is *not* given.  Causes make_*() and the functions
# called thereby to print progress messages to the console since SIMH
# and OS/8 output is not being sent there to clue the user into the
# script's progress.
progmsg = True

# Optional sections encountered. Is a stack because optional sections
# can be nested.
options_stack = []

# List of options enabled on command line.
options_set = []

# Name of the RK05 disk image files we create
_bin_rk05 =           "os8v3d-bin.rk05"
_src_rk05 =           "os8v3d-src.rk05"
_patched_rk05 =       "os8v3d-patched.rk05"
_v3f_build_rk05 =     "os8-v3f-build.rk05"

# Names of DECtape image files we use.
_ro_boot_tape =       "al-4711c-ba-os8-v3d-1.1978.tu56"
_ro_boot_tape_path =  dirs.os8mi + _ro_boot_tape
_driver_tape =        "al-4712c-ba-os8-v3d-2.1978.tu56"
_driver_tape_path =   dirs.os8mi + _driver_tape
_local_tape =         "local.tu56"
_local_tape_path =    dirs.os8mi + _local_tape


# Name of the DECtape image file we create
_new_sys_tape_prefix = "system"

# Parser regexps used in patcher
_com_os8_parse_str = "^\.([a-zA-Z]+)\s?(.*)$"
_com_os8_parse = re.compile(_com_os8_parse_str)
_com_split_str = "^([a-zA-Z]+)\s?(.*)$"
_com_split_parse = re.compile(_com_split_str)
_odt_parse_str = "^([0-7]+)\s?/\s?(\S+)\s+([0-7;]+)"
_odt_parse = re.compile(_odt_parse_str)

# Simple regex to separate command keyword from rest of line.
# rest is in group(3)
_comm_re_str = "^(\S+)(\s+(.*))?$"
_comm_re = re.compile(_comm_re_str)

# Simple regex to identify an end comm and put the rest
# the rest of the line in group(1)
_end_comm_re = re.compile ("^end\s+(.*)?$")

# Simple regex to identify an end option command and put
# the rest of the line in group(1)
_end_option_comm_re = re.compile ("^end\s+option\s+(.*)$")

# Simple regex to identify a begin command and put
# the rest of the line in group(1)
_begin_option_comm_re = re.compile ("^begin\s+option\s+(.*)$")

# Regex for parsing an argument string into a sys device
_mount_regex_str = "^(rk|td|dt|rx)(\d?)\s+(.*)$"
_mount_re = re.compile(_mount_regex_str)

# Map of SIMH device names to OS/8 device name prefixes.
_os8_from_simh_dev = {"rk" : "RK", "td" : "DTA", "dt" : "DTA", "rx" : "RX"}

_os8_partitions = {"RK": ["A", "B"]}

# OS/8 file name matching regex
_os8_file_re = re.compile("(\S+):(\S+)?")

# Regular expression for syntax checking inside FOTP
# Destination is in group(1), Source is in group(3)
_fotp_re = re.compile ("^((\S+:)?\S+)<((\S+:)?\S+)$")

# Regular expression for detecting the 2 arg and 3 arg forms
# of the "pal8" script command.

# OS/8 name regex template:
# Optional device spec, i.e. DTA0:
# File spec with a specific extension or no extension.

_os8_fspec = Template ("((\S+:)?([A-Z0-9]{1,6}|[A-Z0-9]{1,6}\.$ext))")
_os8_BN_fspec = _os8_fspec.substitute(ext="BN")
_os8_PA_fspec = _os8_fspec.substitute(ext="PA")
_os8_LS_fspec = _os8_fspec.substitute(ext="LS")

# For the two arg form:
# The full destination spec is in group(1), The full source spec is in group(4).
# The device components, if any, are in group(2) for destination, and
# group(5) for source.
# The file components are in group(3) for destination, and group (6) for source.
# The destination file must either end in ".BN" or have no extension.
# The source must file either end in ".PA" or have no extension.
_two_arg_pal_re = re.compile ("^" + _os8_BN_fspec + "<" + _os8_PA_fspec + "$")

# For the 3 arg form:
# The full destination spec is in group(1), The full source spec is in group(7).
# The full listing spec is in group(4)
# The device components, if any, are in group(2) for destination, group(5)
# for listing, and group(8) for source.
# The file components are in group(3) for destination, and group(9) for source,
# and group(6) for listing.
# The destination file must either end in ".BN" or have no extension.
# The source must file either end in ".PA" or have no extension.
# The listing must either end in "LS" or have no extension.

_three_arg_pal_re = re.compile ("^" + _os8_BN_fspec + "," + _os8_LS_fspec + "<" + _os8_PA_fspec + "$")

# Regular expression for syntax checking inside ABSLDR
# One or more OS/8 binary files and optional args beginning with a slash.

_absldr_re = re.compile ("^" + _os8_BN_fspec + "(," + _os8_BN_fspec + ")*(/\S)*$")


# Array of regular expressions for syntax checking inside BUILD
_build_comm_regs = {"LOAD"  : re.compile("^(\S+:)?\S+(.BN)?$"),
                    "UNLOAD": re.compile("^\S+(,\S+)?$"),
                    "INSERT": re.compile("^\S+,\S+(,\S+)?$"),
                    "DELETE": re.compile("^\S+(,\S+)?$"),
                    "SYSTEM": re.compile("^\S+$"),
                    "DSK"   : re.compile("^(\S+:)?\S+$"),
                    "BUILD" : re.compile("^(\S+(.BN)?)\s+(\S+(.BN)?)$"),
                    "PRINT" : None,
                    "BOOT"  : None,
                    "end"   : None}



#### mkos8_abort  ######################################################
# Fatal error. Abort mkos8
# Assumes we are in SIMH context. Quit SIMH

def mkos8_abort (s):
  print "Fatal Error.  Cannot proceed."
  s.quit ()
  exit (-1)

#### mkos8_abort_os8  ##################################################
# Fatal error. Abort mkos8
# Assumes we are in os8 context.  Exit to SIMH, then quit SIMH.

def mkos8_abort_os8 (s):
  print "Fatal Error.  Cannot proceed."
  s.back_to_cmd("\\.")        
  s.quit ()
  exit (-1)


#### check_exists ######################################################
# Check existence of all files needed

def check_exists (s, image_copyins):
  for copyin in image_copyins:
    image = copyin[1]
    image_path = dirs.os8mi + image
    if (not os.path.isfile(image_path)):
        print "Required file: " + image_path + " not found."
        mkos8_abort(s)
    # else: print "Found " + image_path

   
#### Data Structures ##################################################
#
# The make procedures use helper procedures
# to confirm that the relevant input image file exists and
# to perform the file copies.
#
# A data structure called "image copyin"
#    describes the image file pathname relative to an implied root,
#    provides a message string when the action is run,
#    names a default destination device for whole image content copies,
#    offers an optional array of specific file copy actions.
#
# FUTURE: Parse source path for ".tu56" vs. ".rk05" for more general use.
# Currently all code assumes a copyin comes from a DECtape image.
#
# Example: We Install all files for ADVENT, the Adventure game:
#
# advent_copyin = ['RKB0:', 'subsys/advent.tu56',  "Installing ADVENT...", None]
#
# A DECtape device is chosen for attachment in SIMH and
# a 'COPY *.*' command is filled in with the Destination device, and the chosen DECtape.
#
# A data structer called "file copyin"
#     provides override destination to allow renames or varied destinations.
#     names individual files within a copyin to use
#
# Example:  To copy the C compiler we want all .SV files on SYS
#           but everything else to RKB0:
#           (Note the useful /V option to invert the match.)
#
# cc8_sv_file_copyin   = ['SYS:', '*.SV']
# cc8_rest_file_copyin = ['RKB0:', '*.SV/V']
#
# A 'COPY' command is filled in with the override destination and
# The file spec is used with the chosen dectape instead of "*.*"
#

#### copyin_pair #######################################################
# Copy two images into two destinations with two messages
#
# Assumes our context is "in simh".
# Assumes dt0 and dt1 are free.
# Assumes rk0 is the boot device
# Detaches dt0 and dt1 after using them.
# copyin0 mounts on dt0.  copyin1 mounts on dt1.
# Either copyin or both can be None

def copyin_pair (s, copyin0, copyin1, debug):
  if debug:
    if copyin0:
      print "Copying: " + copyin0[1] + " to: " + copyin0[0] + "from dt0"
    else: print "copyin0 is empty."
    if copyin1:
      print "Copying: " + copyin1[1] + " to: " + copyin1[0] + "from dt1"
    else: print "copyin1 is empty."
    
  if not copyin0 and not copyin1: return   # Nothing to do.

  # The order of events here is a bit funky because we want
  # to use both DECtape drives but also
  # switch between SIMH and OS/8 as infrequently as possible.

  if copyin0: s.send_cmd ("attach -r dt0 " + dirs.os8mi + copyin0[1])
  if copyin1: s.send_cmd ("attach -r dt1 " + dirs.os8mi + copyin1[1])

  s.os8_restart()

  if copyin0:
    if progmsg: print copyin0[2]
    if copyin0[3]:                    # We have specific files to do.
      for file_copyin in copyin0[3]:
        s.os8_send_cmd ("\\.", "COPY " + file_copyin[0] + "<DTA0:" + file_copyin[1])
    else:
      s.os8_send_cmd ("\\.", "COPY " + copyin0[0] + "<DTA0:*.*")

  if copyin1:
    if progmsg: print copyin1[2]
    if copyin1[3]:                    # We have specific files to do.
      for file_copyin in copyin1[3]:
        s.os8_send_cmd ("\\.", "COPY " + file_copyin[0] + "<DTA1:" + file_copyin[1])
    else:
      s.os8_send_cmd ("\\.", "COPY " + copyin1[0] + "<DTA1:*.*")

  s.back_to_cmd("\\.")

  if copyin0: s.send_cmd ("detach dt0")
  if copyin1: s.send_cmd ("detach dt1")


#### do_all_copyins ####################################################

def do_all_copyins (s, copyins, debug):
  pair_idx = 0
  pair_ct = int(len(copyins) / 2)
  while pair_idx < pair_ct:
    copyin_pair(s, copyins[pair_idx * 2], copyins[pair_idx * 2 + 1], debug)
    pair_idx += 1
  if pair_ct * 2 < len(copyins):
    copyin_pair(s, copyins[len(copyins) - 1], None, debug)

  
#### make_bin ##########################################################
# Top-level driver for the "make binary OS/8 RK05 disk image" process.
#
# If there is already an RK05 binary destination image, moves it aside
# to a ".save" instance, overwriting the previous .save if it exists.
#
# One of the input images is used as a bootable DECtape.
# That DECtape gets written on.
# It needs stuff from tape #2
# So the first two DECtapes
# are treated separately and specially.
# All the other DECtape images used are read only.

def make_bin (s, args):
  boot_dt_path = dirs.os8mo + "bootable-al-4711-c-ba-os8-v3d-1.1978.tu56"

  special_bin_copyins = [
    ["", _ro_boot_tape,  "", None],
    ['RKA0:', _driver_tape, "Device Drivers...", None],
  ]

  music_copyin  = ['RKB0:', 'subsys/music.tu56',
                    "Copying in Music score files and source code...", None]

  ba_copyin     = ['RKB0:', 'subsys/ba.tu56',
                   "Installing *.BA BASIC games and demos...", None]

  cc8_files     = [['SYS:', '*.SV'], ['RKB0:', '*.SV/V']]

  cc8_copyin    = ['RKB0:', 'subsys/cc8.tu56',
                   "Installing Ian Schofield's CC8 compiler...", cc8_files]

  k12_copyin    = ['RKA0:', 'subsys/k12.tu56',
                   "Installing Kermit-12...", None]

  focal69_files  = [
    ['RKB0:', 'FOCAL.BN'],
    ['RKB0:', '4WORD.BN'],
    ['RKB0:', '4KVT.BN'],
    ['RKB0:', '8KVT.BN'],
    ['RKB0:', '8KNOVT.BN']
  ] 
  focal69_copyin = ['RKA0:', 'subsys/focal69.tu56',
                    "Installing FOCAL 69...", focal69_files]

  fiv_copyins = [
    ['RKA0:', "subsys/al-4549d-ba-fr4-v3d-1.1978.tu56",
     "Installing FORTRAN IV ...", None],
  ]

  # Specify files explicitly. There's a README.TX we don't want copied.
  # We may decide to leave FUTIL.SV out.
  macrel_files = [
    ['SYS:', 'MACREL.SV'],
    ['SYS:', 'LINK.SV'],
    ['SYS:', 'KREF.SV'],
    ['SYS:', 'OVRDRV.MA'],
    ['SYS:', 'FUTIL.SV']
  ]

  macrel_copyin = ['RKA0:', "al-5642c-ba-macrel-v2-futil-v8b-by-hand.tu56",
                   "Installing MACREL V2 and new FUTIL V8B ...", macrel_files]

  uwfocal_files  = [['SYS:', 'UWF16K.SV']]
  
  uwfocal_copyin = ['RKA0:', 'subsys/uwfocal-v4e-2.tu56',
                    "Installing U/W FOCAL...", uwfocal_files]

  advent_copyin = ['RKB0:', 'subsys/advent.tu56',
                   "Installing ADVENT...", None]

  bin_copyins = [
    ['RKA0:', "al-4761c-ba-os8-v3d-ext.1978.tu56",
     "Copying in OS/8 V3D extensions...", None],
    ]

  local_files = []
  local_stat_str = "Performing copyins from " + _local_tape + ":\n"

  # Case Conversion scripts from local.tu56.
  local_stat_str += "    Case Conversion batch scripts.\n"
  local_files.append(['RKA0:', '?CSYS.BI'])
  local_files.append(['RKA0:', '?CBAS.BI'])

  if not args.disable_chess:
    local_stat_str += "    CHESS.SV binary and CHESS.TX documentation...\n"
    local_files.append(['RKA0:', 'CHESS.*'])

  if args.enable_vtedit:
    local_stat_str += "    TECO VTEDIT setup...\n"
    local_files.append(['RKA0:', 'VTEDIT.*'])
    local_files.append(['RKA0:', 'TECO.IN'])

  if not args.disable_dcp:
    # Should we also install DCP.WU on RKB0:?
    local_stat_str += "    DCP Disassembler: DCP24.SV, and DCP16.SV as DCP.SV.\n"
    local_files.append(['RKA0:', 'DCP24.SV'])
    local_files.append(['RKA0:DCP.SV', 'DCP16.SV'])

  if args.enable_music:           bin_copyins.append(music_copyin)

  if not args.disable_advent:     bin_copyins.append(advent_copyin)
  if not args.disable_ba:         bin_copyins.append(ba_copyin)
  if not args.disable_cc8:        bin_copyins.append(cc8_copyin)
  if not args.disable_k12:        bin_copyins.append(k12_copyin)
  if not args.disable_fortran_iv: bin_copyins.extend(fiv_copyins)
  if not args.disable_macrel:     bin_copyins.append(macrel_copyin)

  if local_files != []:
    local_copyins = ['RKA0:', _local_tape, local_stat_str, local_files]
    bin_copyins.append(local_copyins)

  if args.enable_focal69:
    bin_copyins.append(focal69_copyin)
  if not args.disable_uwfocal:
    bin_copyins.append(uwfocal_copyin)

  check_exists(s, special_bin_copyins)
  check_exists(s, bin_copyins)

  print "Generating " + _bin_rk05 + " from " + str(len(bin_copyins) + 2) + \
        " source tapes..."

  image_path = dirs.os8mo + _bin_rk05
  if os.path.isfile(image_path):
    save_path = dirs.bin + _bin_rk05 + ".save"
    print "Pre-existing " + _bin_rk05 + " found.  Saving as " + _bin_rk05 + ".save"
    if os.path.isfile(save_path):
      print "Overwriting old " + _bin_rk05 + ".save"
      os.remove(save_path)
    os.rename(image_path, save_path)
  
  global progmsg
  if progmsg: print "Building initial OS/8 system..."
  
  if progmsg: print "Making a writeable copy of boot DECtape..."
  try:
    shutil.copyfile(_ro_boot_tape_path, boot_dt_path)
  except shutil.Error as e:
    print "Bootable DECtape copy failed with error: " + e
    mkos8_abort (s)
  except IOError as e:
    print "Bootable DECtape copy failed with IOError: " + e
    mkos8_abort (s)

  s.send_cmd ("attach rk0 " + image_path)
  s.send_cmd ("attach dt0 " + boot_dt_path)
  s.send_cmd ("attach -r dt1 " + _driver_tape_path)

  if progmsg: print "Performing config with BUILD..."
  s.send_cmd ("boot dt0")

  # By default, we're going to have an INIT.CM script, but we don't want
  # to set it up this early for two reasons.  First, we don't want the
  # "boot rk0" commands below to emit this message, since its text
  # varies depending on the host system, which would create unnecessary
  # differences in our output over time.  Second, OS/8 is alleged not to
  # always build properly if INIT is enabled in these early stages.
  s.os8_send_cmd ("\\.", "SET SYS NO INIT")

  s.os8_send_cmd ("\\.", "RUN SYS BUILD")
  s.os8_send_cmd ("\$", "LOAD DTA1:RK8ESY.BN")
  s.os8_send_cmd ("\$", "LOAD DTA1:PT8E.BN")
  s.os8_send_cmd ("\$", "DELETE SYS")
  s.os8_send_cmd ("\$", "SYSTEM RK8E")
  s.os8_send_cmd ("\$", "DELETE RXA1")
  s.os8_send_cmd ("\$", "INSERT PT8E,PTR")
  s.os8_send_cmd ("\$", "INSERT PT8E,PTP")
  s.os8_send_cmd ("\$", "DELETE RKA0")
  s.os8_send_cmd ("\$", "DELETE RKB0")
  s.os8_send_cmd ("\$", "INSERT RK8E,RKA0,RKB0")
  s.os8_send_cmd ("\$", "INSERT RK05,RKA2,RKB2")
  s.os8_send_cmd ("\$", "DELETE DTA0")
  s.os8_send_cmd ("\$", "INSERT TC,DTA0")
  s.os8_send_cmd ("\$", "DSK RK8E:RKB0")
  s.os8_send_cmd ("\$", "PRINT")
  s.os8_send_cmd ("\$", "BOOT")
  s.os8_send_cmd ("WRITE ZERO DIRECT\?", "Y")
  # SYS is now RK0; if we SAVE SYS we will overwrite with wrong BUILD.SV
  s.os8_send_cmd ("\\.", "SAVE DTA0 BUILD")
  s.back_to_cmd("\\.")
  
  if progmsg: print "Copying OS/8 system files from TU56 source to RK05 image..."
  if progmsg: print "Copying in system tape 1 of 2..."
  s.send_cmd ("boot dt0")
  s.os8_send_cmd ("\\.", "COPY RKA0:<DTA0:*.*")

  # There are not enough directory entries to put everything
  # Including all device drivers on the running packs.
  # So we DONT copy in the device drivers, nor TDINIT.SV,
  # nor the two TD8E-based DECtape system area files.
  # CCL.PA and KL8E.PA will be on the source disk.
  # However DECtape 2 has HELP.HL and .RL files that ARE needed.
  # if progmsg: print "Copying in system tape 2 of 2..."
  # s.os8_send_cmd ("\\.", "COPY RKA0:<DTA1:*.*")
  if progmsg: print "Copying in help files..."
  s.os8_send_cmd ("\\.", "COPY RKA0:<DTA1:*.HL")

  if args.disable_fortran_ii:
    files = [ 'RKA0:{0}.SV'.format(f) for f in [
        'FORT', 'LIBSET', 'SABR'
      ]
    ]
    s.os8_send_cmd ("\\.", 'DEL ' + ','.join (files))
  else:
    if progmsg: print "Installing FORTRAN II libraries..."
    s.os8_send_cmd ("\\.", "COPY RKA0:<DTA1:*.RL")

  s.os8_send_cmd ("\\.", "ZERO RKB0:")      # must precede subsys/* copies

  s.back_to_cmd("\\.")
  
  if progmsg: print "Deleting bootable copy of DECtape image and"
  if progmsg: print "rebooting into freshly-built RK05 OS/8 system..."
  s.send_cmd ("detach dt0")
  s.send_cmd ("detach dt1")
  s.send_cmd ("boot rk0")     # must do: boot media just went away
  s.back_to_cmd("\\.")
  os.remove(boot_dt_path)

  if progmsg: print "Performing remaining copies/installs..."
  do_all_copyins (s, bin_copyins, args.debug)

  # Any further initialization of installed software is done here.
  s.send_cmd ("boot rk0")

  if progmsg: print "Configuring for 3-column DIRECT listings..."
  s.os8_send_cmd ("\\.", "SET TTY COL 3")

  if not args.disable_crt:
    # NO SCOPE mode is the default on distribution tapes.
    if progmsg: print "Configuring scope-style rubout processing..."
    s.os8_send_cmd ("\\.", "SET TTY SCOPE")
  
  # Make sure Scripts are included in local_files array!
  # Or this will fail.
  if not args.disable_lcmod:
    if progmsg: print "Patching OS/8 to upcase commands only; SIMH is set not to auto-upcase."
    s.os8_send_cmd ("\\.", "SUBMIT SYS:LCSYS.BI")
    if progmsg: print "Patching OS/8 BASIC to cope with lower case input"
    s.os8_send_cmd ("\\.", "SUBMIT SYS:LCBAS.BI")

  # Create a banner message and optionally set it to show on boot.
  # This message is always upcased, even if you do this before calling
  # LCSYS.BI.  Is it a limitation of EDIT?
  #
  # Note that we do not read this file from dirs.os8mi: it is either an
  # output of autosetup or overwritten by test-mkos8 in the *build*
  # tree, so that when building out of tree, reading from os8mi would
  # either give an empty file if the source tree was "clean" or a
  # mismatched version of the file from the soruce tree rather than the
  # one we want, which is in the *build* tree.
  if progmsg: print "Setting INIT message..."
  s.os8_send_file ('media/os8/init.tx')
  s.os8_send_cmd ("\\.", "CREATE INIT.CM")
  s.os8_send_cmd ("#", "A")
  s.os8_send_line("TYPE INIT.TX")
  s.os8_send_ctrl('L')
  s.os8_send_cmd ("#", "E")
  if not args.disable_init:
    # Set the message to display only if the user did not suppress it.
    # We do it this way so the user can turn it on later without
    # rebuilding their OS/8 media.
    s.os8_send_cmd ("\\.", "SET SYS INIT")

  # Finish up
  if progmsg: print "Cleaning up..."
  s.os8_squish ("SYS")
  s.os8_squish ("DSK")
  s.back_to_cmd("\\.")
  s.send_cmd ("detach rk0")



#### make_src ##########################################################
# Source-disk version of make_bin() above.

def make_src (s, args):
  src_copyins = [
    ["RKA1:", "al-4691c-sa-os8-v3d-1.1978.tu56", "...part 1 of 7...", None],
    ["RKA1:", "al-4692c-sa-os8-v3d-2.1978.tu56", "...part 2 of 7...", None],
    ["RKA1:", "al-4693d-sa-os8-v3d-3.1978.tu56", "...part 3 of 7...", None],
    ["RKA1:", "al-4694c-sa-os8-v3d-4.1978.tu56", "...part 4 of 7...", None],
    ["RKB1:", "al-4695c-sa-os8-v3d-5.1978.tu56", "...part 5 of 7...", None],
    ["RKB1:", "al-4696c-sa-os8-v3d-6.1978.tu56", "...part 6 of 7...", None],
    ["RKB1:", "al-4697c-sa-os8-v3d-7.1978.tu56", "...part 7 of 7...", None],
    ["RKB1:", "al-4759c-sa-os8-ext-1.1978.tu56",
     "extensions part 1 of 3...", None],
    ["RKB1:", "al-4760c-sa-os8-ext-2.1978.tu56", "...part 2 of 3...", None],
    ["RKA1:", "al-5586c-sa-os8-ext-3.1978.tu56", "...part 3 of 3...", None],
  ]
  
  check_exists (s, src_copyins)

  print "Generating " + _src_rk05 + " from " + str(len(src_copyins)) + \
        " source tapes..."

  bin_path = dirs.os8mo + _bin_rk05
  if (not os.path.isfile(bin_path)):
    print _bin_rk05 + " is needed to build src.  Creating..."
    make_bin(args)

  src_path = dirs.os8mo + _src_rk05
  if os.path.isfile(src_path):
    save_path = src_path + ".save"
    print "Pre-existing " + _src_rk05 + " found.  Saving as " + _src_rk05 + ".save"
    if os.path.isfile(save_path):
      print "Overwriting old " + _src_rk05 + ".save"
      os.remove(save_path)
    os.rename(src_path, save_path)
    
  if progmsg: print "Copying OS/8 source distribution:"
  s.send_cmd ("attach rk0 " + bin_path)
  s.send_cmd ("attach rk1 " + src_path)

  s.send_cmd ("boot rk0")
  
  s.os8_send_cmd ("\\.", "ZERO RKA1:")
  s.os8_send_cmd ("\\.", "ZERO RKB1:")

  s.back_to_cmd("\\.")

  do_all_copyins (s, src_copyins, args.debug)

  if progmsg: print "Cleaning up..."
  s.send_cmd ("detach rk0")
  s.send_cmd ("detach rk1")


#### parse_odt #########################################################

def parse_odt (s, com, line, debug):
  if debug: print line
  
  if line == "\\c": return "break"
  match = _odt_parse.match(line)
  if match == None:
    print "Aborting because of bad ODT line: " + line
    s.os8_send_ctrl('C')
    return "err"
  loc = match.group(1)
  old_val = match.group(2)
  new_val = match.group(3)
  expect_val_str = "\s?[0-7]{4} "
  
  if debug: print "Loc: " + loc + ", old_val: " + old_val + ", new_val: " + new_val
  s.os8_send_str (loc + "/")
  s._child.expect(expect_val_str)

  if old_val.isdigit():          # We need to check old value
    found_val = s._child.after.strip()
    if found_val != old_val:
      print "Old value: " + found_val + " does not match " + old_val + ". Aborting patch."
      # Abort out of ODT back to the OS/8 Monitor
      s.os8_send_ctrl('C')
      return "err"

  s.os8_send_line (new_val)
  return "cont"


#### futil_exit ########################################################

def futil_exit (s, com, line):
  s.os8_send_line(line)
  return "break"


#### futil_file ########################################################

def futil_file (s, com, line):
  # Redundant re-parse of line but nobody else wants args right now.
  match = _com_split_parse.match(line)
  if match == None:
    print "Aborting because of mal-formed FUTIL FILE command: " + line
    s.os8_send_ctrl('C')
    return "err"
  fname = match.group(2)
  expect_futil_file_str = "\n" + fname + "\s+(.*)$"
  s.os8_send_line (line)
  s._child.expect(expect_futil_file_str)
  result = s._child.after.strip()
  match = _com_split_parse.match(result)
  if match == None:
    print "Aborting because unexpected return status: " + result + " from: " + line
    s.os8_send_ctrl('C')
    return "err"
  if match.group(2).strip() == "LOOKUP FAILED":
    print "Aborting because of FUTIL lookup failure on: " + fname
    s.os8_send_ctrl('C')
    return "err"
  else:
    return "cont"
  
  
#### parse_futil #########################################################
#
# Very simple minded:
# If first char on line is an alpha, run the command.
# If the first char on line is number, do the substitute command.
#
# Substitute command acts like ODT.
# Future version should support the IF construct.
#
# When we encounter the EXIT command, we return success.

def parse_futil (s, com, line, debug):
  futil_specials = {
    "EXIT": futil_exit,
    "FILE": futil_file
  }

  if line[0].isdigit():
    # Treat the line as ODT
    return parse_odt(s, com, line, debug)
  else:
    match = _com_split_parse.match(line)
    if match == None:
      print "Ignoring failed FUTIL command parse of: " + line
      return "cont"
    fcom = match.group(1)
    rest = match.group(2)

    if fcom not in futil_specials:
      # Blind faith and no error checking.
      s.os8_send_line(line)
      return "cont"
    else:
      return futil_specials[fcom](s, fcom, line)


#### do_patch_file #####################################################

def do_patch_file (s, filename, debug):
  global progmsg
  
  try:
    patch_file = open(dirs.os8mi + "patches/" + filename, "r")
  except IOError:
    print filename + " not found. Skipping."
    return -1

  special_commands = {
    "ODT": parse_odt,
    "R": None,               # Get next parser.
    "FUTIL": parse_futil
  }

  inside_a_command = False
  the_command = ""
  the_command_parser = None
  
  for line in patch_file:
    line = line.rstrip()
    if line == "": continue
    elif line[0] == '#': continue     # Ignore Comments
    elif inside_a_command:
      retval = the_command_parser (s, the_command, line, debug)
      if retval == "break":
        inside_a_command = False
        s.os8_send_ctrl('C')
      elif retval == "err":
        patch_file.close()
        return -1
    elif line[0] == '.':        # New OS/8 Command
      match = _com_os8_parse.match(line)
      if match == None:
        print "Aborting patch on failed OS/8 command parse of: " + line
        return -1
      com = match.group(1)
      rest = match.group(2)

      if com in special_commands:
        if com == "R":
          # Run command is special.  Take arg as the command and run it.
          com = rest
        inside_a_command = True
        the_command = com
        the_command_parser = special_commands[com]

      # We carefully separate com and args
      # But don't make much use of that yet.
      if progmsg and debug: print line
      s.os8_send_cmd ("\\.", line[1:])  # Skip Prompt.

  patch_file.close()

  # Done.  Signal success.
  return 0


#### skip_patch ########################################################
# Returns true if the given filename matches one of the regex string
# keys of the given skips dict and the flag value for that key is set.
# See skips definition in make_patch, which calls this.

def skip_patch (fn, skips):
    for p in skips:
        if re.search (p, fn) and skips[p]: return True
    return False

      
#### make_patch ########################################################

def make_patch (s, args):
  global progmsg
  
  manifest_filename = "patch_list.txt"

  # Declare which patches to skip based on patch file name RE patterns
  # and command line options.  All patches not matching these patterns
  # apply to OS/8 files that always get installed.
  skips = {
    '^F4':            args.disable_fortran_iv,
    '^FRTS':          args.disable_fortran_iv,
    '^FUTIL.*v7': not args.disable_macrel,     # MACREL includes FUTIL V8B
    '^SABR':          args.disable_fortran_ii,
  }

  print "Generating " + _patched_rk05 + " from " + _bin_rk05

  image_path = dirs.os8mo + _patched_rk05
  if os.path.isfile(image_path):
    save_path = dirs.bin + _patched_rk05 + ".save"
    print "Pre-existing " + _patched_rk05 + " found.  Saving as " + _patched_rk05 + ".save"
    if os.path.isfile(save_path):
      print "Overwriting old " + _patched_rk05 + ".save"
      os.remove(save_path)
    os.rename(image_path, save_path)

  if progmsg: print "Copying original " +  _bin_rk05 + " to " + _patched_rk05
  try:
    shutil.copyfile(dirs.os8mo + _bin_rk05, image_path)
  except shutil.Error as e:
    print "Creation of " + _patched_rk05 + " failed with error: " + str(e)
    mkos8_abort(s)
  except IOError as e:
    print "Creation of " + _patched_rk05 + " failed with IOError: " + str(e)
    mkos8_abort(s)

  s.send_cmd ("attach rk0 " + image_path)
  s.send_cmd ("boot rk0")         # We're running OS/8. Let's patch!
  
  manifest = open (dirs.os8mi + "patches/" + manifest_filename, "r")

  for line in manifest:
    if line == "": continue
    if line[0] == '#': continue      # Allow commenting out files

    filename = line.strip()
    if skip_patch (filename, skips):
      if progmsg: print "Skipping patch file: " + filename + "."
    else:
      if progmsg: print "Applying patch file: " + filename + "...",
      success = do_patch_file (s, filename, args.debug) == 0
      if progmsg:
        if success:
          print "success."
        else:
          print "FAILED!"
  
  # If we have installed FORTRAN IV, install the patched FORLIB.RL
  # to be found on local.tu56
  if not args.disable_fortran_iv:
    forlib_tape =         "local.tu56"
    forlib_tape_path =    dirs.os8mi + forlib_tape
    if progmsg: print "FORLIB 51.10.1M: Replacing FORLIB.RL with patched version from " + forlib_tape + "..."
    # Normally we'd use check_exists, but failure to find the file is fatal.
    # With a patch, we abort but keep going.
    if (not os.path.isfile(forlib_tape_path)):
      print "Can't find tape with patch FORLIB.RL.  FAILED!"
    else:
      s.back_to_cmd("\\.")         # return to simh and mount the tape.
      s.send_cmd ("attach -r dt0 " + forlib_tape_path)
      s.os8_restart ()            # return to OS/8
      s.os8_send_cmd ("\\.", "DEL SYS:FORLIB.RL")
      s.os8_send_cmd ("\\.", "COPY SYS:<DTA0:FORLIB.RL")
      s.back_to_cmd("\\.")         # return to simh and mount the tape.
      s.send_cmd ("detach dt0")
      s.os8_restart ()            # return to OS/8
      
  # Finish up
  if progmsg: print "Cleaning up..."
  s.os8_squish ("SYS")
  s.os8_squish ("DSK")
  s.back_to_cmd("\\.")
  s.send_cmd ("detach rk0")

#### make_system_tape ##################################################
# Make and install new OS/8 System Head.
# ISSUE: Doing this will probably break the LC/UC batch scripts.

def old_make_system_tape (s, args):
  sys_path = dirs.os8mo + _patched_rk05
  build_path = dirs.os8mo + _v3f_build_rk05

  if not os.path.isfile(sys_path):
    print "System pack: " + sys_path + " not found."
    mkos8_abort(s)
  if not os.path.isfile(build_path):
    print "OS/8 V3F build image: " + build_path + " not found."
    mkos8_abort(s)

  sys_tape_path = dirs.os8mo + _new_sys_tape_prefix + ".tu56"
  # Created system tapes may be precious.  We avoid overwriting tape
  # "system<number>.tu56" by creating a new tape "system<number+1>.tu56".
  next_tape = 0
  while os.path.isfile(sys_tape_path):
    print "Found: " + sys_tape_path
    next_tape += 1
    sys_tape_path = dirs.os8mo + _new_sys_tape_prefix + str(next_tape) + ".tu56"

  # Put the drivers dectape on dt1
  s.send_cmd ("attach -r dt1 " + _driver_tape_path)
  # Put the new system tape on dt0
  s.send_cmd ("attach dt0 " + sys_tape_path)
  # System is the patched rk05 image.
  s.send_cmd ("attach rk0 " + sys_path)
  # RK1 hosts the v3f build pack we will work with.
  s.send_cmd ("attach rk1 " + build_path)
  s.send_cmd ("boot rk0")         # We're running OS/8. Let's build!

  # We need some files on DSK:
  # or else BUILD of system head will fail.
  s.os8_send_cmd ("\\.", "COPY DSK:<RKB1:OS8.BN,CD.BN")
  
  # Run build from v3f image to create the system.
  # Although it would be nice to just load all drivers
  # BUILD has limited space, and detectin the error,
  # "?NO ROOM" is a pain.
  s.os8_send_cmd ("\\.", "RUN RKB1 BUILD")
  s.os8_send_cmd ("\$", "LOAD DTA1:RK8ESY.BN")
  s.os8_send_cmd ("\$", "LOAD DTA1:RK8ENS.BN")
  s.os8_send_cmd ("\$", "LOAD DTA1:PT8E.BN")
  # Here we choose between TCO8, TD8E with either 12K or ROM
  # Currently done with commenting out code.
  # Need to conceive a structure for specifying these choices.
  s.os8_send_cmd ("\$", "LOAD DTA1:TC08SY.BN")
  s.os8_send_cmd ("\$", "LOAD DTA1:TC08NS.BN")
  # TD8E 12K
  # s.os8_send_cmd ("\$", "LOAD DTA1:TD8ESY.BN")
  # TD8E with ROM
  # s.os8_send_cmd ("\$", "LOAD DTA1:ROMMSY.BN")
  
  # Non-System Handlers for up to 8 TD8E drives:
  # TD8EA for units 0 and 1.
  s.os8_send_cmd ("\$", "LOAD DTA1:TD8EA.BN")
  # TD8EB for units 2 and 3.
  # s.os8_send_cmd ("\$", "LOAD DTA1:TD8EB.BN")
  # TD8EC for units 4 and 5.
  # s.os8_send_cmd ("\$", "LOAD DTA1:TD8EC.BN")
  # TD8ED for units 6 and 7.
  # s.os8_send_cmd ("\$", "LOAD DTA1:TD8ED.BN")

  s.os8_send_cmd ("\$", "LOAD DTA1:KL8E.BN")
  s.os8_send_cmd ("\$", "LOAD DTA1:LPSV.BN")
  
  # We will configure for RX02 support by default.
  s.os8_send_cmd ("\$", "LOAD RKB1:RXSY2.BN")
  s.os8_send_cmd ("\$", "LOAD RKB1:RXNS.BN")
  
  # Some physical configurations will have RX01
  # and will need the following instead:
  # Note that BUILD calls BOTH the RX01 and RX02
  # handlers, "RX8E" so you have to pick ONE to load.
  # s.os8_send_cmd ("\$", "LOAD RKB1:RXSY.BN")
  # The non-system handler with v3f may or may not work with RK01.
  # s.os8_send_cmd ("\$", "LOAD DTA1:RX01NS.BN")

  s.os8_send_cmd ("\$", "INSERT PT8E,PTR")
  s.os8_send_cmd ("\$", "INSERT PT8E,PTP")
  s.os8_send_cmd ("\$", "INSERT KL8E,TTY")
  s.os8_send_cmd ("\$", "INSERT LPSV,LPT")

  # Now the choice of system and DSK devices
  # TC08
  s.os8_send_cmd ("\$", "SYSTEM TC08")
  s.os8_send_cmd ("\$", "INSERT TC08,DTA0")
  s.os8_send_cmd ("\$", "INSERT TC,DTA1")
  s.os8_send_cmd ("\$", "DSK TC08:DTA0")

  # TD8E with 12K core, not ROM
  # s.os8_send_cmd ("\$", "SYSTEM TD8E")
  # s.os8_send_cmd ("\$", "INSERT TD8E,DTA0")
  # s.os8_send_cmd ("\$", "INSERT TD8E,DTA1")
  # s.os8_send_cmd ("\$", "DSK TD8E:DTA0")

  # TD8E with ROM system handler
  # s.os8_send_cmd ("\$", "SYSTEM ROM")
  # s.os8_send_cmd ("\$", "INSERT ROM,DTA0")
  # s.os8_send_cmd ("\$", "INSERT ROM,DTA1")
  # s.os8_send_cmd ("\$", "DSK ROM:DTA0")

  # TD8E Non-system Handlers
  # s.os8_send_cmd ("\$", "INSERT TD8A,DTA0")
  # s.os8_send_cmd ("\$", "INSERT TD8A,DTA1")
  # s.os8_send_cmd ("\$", "INSERT TD8B,DTA2")
  # s.os8_send_cmd ("\$", "INSERT TD8B,DTA3")
  # s.os8_send_cmd ("\$", "INSERT TD8C,DTA4")
  # s.os8_send_cmd ("\$", "INSERT TD8C,DTA5")
  # s.os8_send_cmd ("\$", "INSERT TD8D,DTA6")
  # s.os8_send_cmd ("\$", "INSERT TD8D,DTA7")

  # RX01  (Only do this if buiding an RX01 image, not a DECtape.)
  # NOTE! In simh make sure you have done:
  # set rx rx8e to configure the device for RX01 mode.
  # s.os8_send_cmd ("\$", "SYSTEM RX8E")
  # s.os8_send_cmd ("\$", "INSERT RX01,RXA0,RXA1")

  # RX02  (Only do this if building a RX02 image, not a DECtape.)
  # NOTE! In simh make sure you have done:
  # set rx rx28 to configure the device for RX01 mode.
  # s.os8_send_cmd ("\$", "SYSTEM RX8E")
  # s.os8_send_cmd ("\$", "INSERT RX02,RXA0,RXA1")

  # In our default config we have room for 3 RKs if
  # we don't run with both RX non-system devices.
  s.os8_send_cmd ("\$", "INSERT RX02,RXA0")

  # RK05 (Only do this if building an RK05 image, not a DECtape.)
  # s.os8_send_cmd ("\$", "SYSTEM RK8E")
  # s.os8_send_cmd ("\$", "INSERT RK8E,RKA0,RKB0")
  # RK05 Non-System Handlers
  s.os8_send_cmd ("\$", "INSERT RK05,RKA0,RKB0")
  s.os8_send_cmd ("\$", "INSERT RK05,RKA1,RKB1")
  s.os8_send_cmd ("\$", "INSERT RK05,RKA2,RKB2")

  # ***CAUTION***
  # When you do this you are instructing BUILD to
  # OVERWRITE the system area.  If you do this to your
  # running RK05 pack by mistake, you WILL make a mess
  # and need to re-run mkos8 to re-make it.
  s.os8_send_cmd ("\$", "BUILD")
  s.os8_send_cmd ("LOAD OS/8: ", "DSK:OS8.BN")
  s.os8_send_cmd ("LOAD CD: ", "DSK:CD.BN")

  s.os8_send_cmd ("\$", "BOOT")
  s.os8_send_cmd ("\\.", "SAVE DTA0 BUILD.SV")

  # Copy a few basics onto the tape from either our SYS
  # or the v3f build image.
  s.os8_send_cmd ("\\.", "RU RKA0:FOTP.SV")
  s.os8_send_cmd ("\\*", "DTA0:<RKA0:FOTP.SV")
  s.os8_send_cmd ("\\*", "DTA0:<RKA0:DIRECT.SV")
  s.os8_send_cmd ("\\*", "DTA0:<RKB1:CCL.SV")
  s.os8_send_cmd ("\\*", "DTA0:<RKB1:RESORC.SV")
  s.os8_send_ctrl ('[')

  # We should figure out how to remove OS8.BN and CD.BN
  # from DSK: to clean up what we have done.  But right now
  # CCL doesn't work.
  
  # Detach our sources in case tape goes crazy
  # when we boot it.
  s.back_to_cmd ("\\.")
  s.send_cmd ("detach dt1")
  s.send_cmd ("detach rk0")
  s.send_cmd ("detach rk1")
  
  # Run a few commands on our new tape system.
  if progmsg: print "The moment of truth... Does the tape boot?"
  s.send_cmd ("boot dt0")
  s.os8_send_cmd ("\\.", "R CCL")
  
  # Finish up
  if progmsg: print "Cleaning up..."
  # s.os8_squish ("DTA0")
  s.back_to_cmd("\\.")
  s.send_cmd ("detach dt0")
  

#### call_pal8 #########################################################
# Generic call out to PAL8 with error recovery.
# We rely on the caller to have good specifications for source,
# binary and optional listing files.

def call_pal8 (s, source, binary):
  pal8_replies = ["ERRORS DETECTED: ", "BE\s+\S+", "CF\s+\S+", "DE\s+\S+", "DF", "IC\s+\S+", "ID\s+\S+",
                  "IE\s+\S+", "II\s+\S+", "IP\s+\S+", "IZ\s+\S+", "LD\s+\S+", "LG\s+\S+", "PE\s+\S+",
                  "PH\s+\S+", "RD\s+\S+", "SE\s+\S+", "UO\s+\S+", "US\s+\S+", "ZE\s+\S+", "\S+ NOT FOUND"]

  # Build OS/8 System head by using PAL-8 to assemble OS8.PA and CD.PA
  if progmsg: print "Assembling " + source
  com_line = binary + "<" + source
  s.os8_send_cmd ("\\.", "R PAL8")
  s.os8_send_cmd ("\\*", com_line)
  err_count = 0
  reply = s._child.expect (pal8_replies)
  executed_line = s._child.before.strip()
  reply_str = s._child.after.strip()
  if reply == 0:
    s._child.expect("\d+")
    err_count = int(s._child.after.strip())
    reply_str += " " + s._child.after.strip()
  if reply > 0 or err_count > 0:
    print "PAL8 Error: "
    print "\t*" + executed_line
    print "\t" + reply_str
    s.os8_send_ctrl ('c')      # exit PAL8 Just in case.
    # We could do something better than just dying, I expect.
    mkos8_abort_os8(s)
  # s.os8_send_ctrl ('[')      # exit PAL8
  

#### make_v3f ##########################################################
# Create an RK05 image containing the OS/8 v3f sources on partition A.
# Build binaries for them into partition B.

def make_v3f (s, args):
  sys_path = dirs.os8mo + _patched_rk05
  build_path = dirs.os8mo + _v3f_build_rk05

  pal_sources = ["OS8", "CD", "RL0", "RL1", "RL2", "RL3", "RLC", "RXSY1",
             "RXSY2", "RXNS"]

  if not os.path.isfile(sys_path):
    print "System pack: " + sys_path + " not found."
    mkos8_abort(s)
  if not os.path.isfile(build_path):
    print "OS/8 V3F build image: " + build_path + " not found."
    mkos8_abort(s)

  s.send_cmd ("attach rk0 " + sys_path)
  s.send_cmd ("attach rk1 " + build_path)
  s.send_cmd ("boot rk0")         # We're running OS/8. Let's build!

  # Build BUILD
  if progmsg: print "Building BUILD."
  call_pal8(s, "RKA1:BUILD.PA","RKB1:BUILD.BN")
  if progmsg: print "Loading and savinging BUILD.SV to RKB1:"
  s.os8_send_cmd ("\\.", "R ABSLDR")
  s.os8_send_cmd ("\*", "RKB1:BUILD.BN")
  s.os8_send_ctrl ('[')
  s.os8_send_cmd ("\\.", "SAVE RKB1:BUILD.SV")

  for pal_src in pal_sources:
    call_pal8 (s, "RKA1:" + pal_src + ".PA", "RKB1:" + pal_src + ".BN")

  # Build RESORC and CCL
  if progmsg: print "Preparing to build CCL and RESORC with BATCH scripts."

  s.os8_send_cmd ("\\.", "ASSIGN RKA1 IN")
  s.os8_send_cmd ("\\.", "ASSIGN RKB1 OUT")

  # BATCH scripts must be on the SYSTEM device.  DSK: will work.
  s.os8_send_cmd ("\\.", "COPY DSK:<RKA1:RESORC.BI")
  s.os8_send_cmd ("\\.", "COPY DSK:<RKA1:CCL.BI")
  
  # The CCL.BI script chains to RESORC.BI
  s.os8_send_cmd("\\.", "SUBMIT CCL.BI")
  # What kind of error trapping can we do here?

  # Delete the batch scripts we copied in.
  s.os8_send_cmd ("\\.", "DEL DSK:<RKA1:RESORC.BI")
  s.os8_send_cmd ("\\.", "DEL DSK:<RKA1:CCL.BI")
  if progmsg: print "RESORC.SV and CCL.SV should be in RKB1:"
  
  # Finish up
  if progmsg: print "Cleaning up..."
  if progmsg: print "Squish RKB1"
  s.os8_squish ("RKB1")
  s.back_to_cmd("\\.")
  s.send_cmd ("detach rk0")
  s.send_cmd ("detach rk1")


#### basic_line_parse ###################################################
# Returns stripped line and any other cleanup we want.
# Returns None if we should just 'continue' on to the next line.
# Filters out comments.
# Processes the option begin/end blocks.

def basic_line_parse (s, args, line, comm_file):
  global options_stack

  if line[0] == "#": return None
  retval = line.strip()
  if retval == "": return None

  # First test if we are in a begin option block
  m = re.match (_begin_option_comm_re, retval)
  if m != None:
    rest = m.group(1)
    print "doing_begin_option: " + rest
    print "options_set: " + str (options_set)

    if rest in options_set:
      # Option is active. We push it onto the stack
      print "Pushing " + rest + " onto options_stack"
      options_stack.insert(0, rest)
    else:
      # Option is inactive.  Ignore all subseqent lines
      # until we get to an end command that matches our option.
      ignore_to_subcomm_end (s, args, line, comm_file, "option " + rest)
    return None

  m = re.match(_end_option_comm_re, line)
  if m != None:
    rest = m.group(1)
    if (rest == None or rest == ""):
      print "Warning! option end statement encountered with no argument."
      return None
    if len(options_stack) == 0:
      print "Warning! option end statement found with no matching begin for option: " + rest
      return None
    if rest != options_stack[0]:
      print "Warning! Mismatched option begin/end group. Currently inside option: " + \
        options_stack[0] + " not " + rest
      return None
    else:
      print "Popping " + options_stack[0]
      options_stack.pop()
      return None

  return retval


#### do_simh_comm ########################################################
# I tried to avoid including this command but sometimes you just
# have to reconfigure subtle bits of device drivers.
# We assume we can call a simh command at any time, but
# doing so puts us in the simh context that persists until we
# issue a boot or go command.

def do_simh_comm (s, args, line, comm_file):
  if progmsg: print line
  s.send_cmd(line)


#### do_umount_comm ######################################################
def do_umount_comm (s, args, line, comm_file):
  detach_comm = "det " + line
  if progmsg: print detach_comm
  s.send_cmd(detach_comm)


#### do_mount_comm ######################################################
# Remember we have to figure out how to differentiate between
# RX01 and RX02

def do_mount_comm (s, args, line, comm_file):
  m = re.match(_mount_re, line)
  if m == None:
    print "Could not parse mount.  Ignoring: " + line
    return
  simh_dev = m.group(1)
  unit = m.group(2)
  rest = m.group(3)
  parts = rest.split()
  if len(parts) == 0:
    print "No image name specified in: " + line
    return
  ro_arg = ""
  imagename = parts[0]
  dot = imagename.rindex(".")
  base_imagename = imagename[:dot]
  extension = imagename[dot:]
  # Case of additional arguments.
  if len (parts) > 1:
    for part in parts[1:]:
      if part == "read-only": ro_arg = "-r "
      elif part == "must-exist":
        if not os.path.exists(imagename):
          print imagename + " must exist but was not found. Not mounting."
          return
      elif part == "no-overwrite":
        next_tape = 0
        while os.path.isfile(imagename):
          print "Found: " + imagename
          next_tape += 1
          imagename =  base_imagename + str(next_tape) + extension
      else:
        print "Ignoring unrecognized mount option: " + part
  if unit == None or unit == "":
    print "Need unit number for: " + line
    return

  if simh_dev not in _os8_from_simh_dev:
    print "Unrecognized simh dev: " + simh_dev
    return
  os8dev = _os8_from_simh_dev[simh_dev]

  attach_comm = "att " + ro_arg + simh_dev + unit + " " + imagename

  if progmsg: print attach_comm
  s.send_cmd(attach_comm)
  

#### do_boot_comm #######################################################

def do_boot_comm (s, args, line, comm_file):
  boot_comm = "boot " + line
  if progmsg: print boot_comm
  s.send_cmd(boot_comm)


#### do_os8_comm ########################################################

def do_os8_comm (s, args, line, comm_file):
  os8_comm = line
  if progmsg: print os8_comm
  s.os8_send_cmd ("\\.", os8_comm)

#### do_pal8_comm ########################################################
# The "pal8" script command comes in two forms:
# The two argument form where the PAL8 status is printed on the fly
# and the 3 argument form where all status goes into the listing file.
# We do the 3 argument form with a simple "os8" script command.

def do_pal8_comm (s, args, line, comm_file):
  m_2form = re.match (_two_arg_pal_re, line)
  if m_2form != None:
    # Call the 2arg pal8 code that works hard at error analysis.
    call_pal8 (s, source=m_2form.group(4), binary=m_2form.group(1))
  else:
    m_3form = re.match (_three_arg_pal_re, line)
    if m_3form != None:
      # Just run the OS/8 command.
      os8_comm = line
      if progmsg: print "Calling 3-arg pal8 command: " + os8_comm
      s.os8_send_cmd ("\\.", os8_comm)
    else:
      print "Unrecognized pal8 form: " + line

    
#### do_done_comm #######################################################
# Return to SIMH from OS/8
# Detach all devices to make sure buffers all get written out.

def do_done_comm (s, args, line, comm_file):
  s.back_to_cmd ("\\.")
  s.send_cmd ("detach all")


#### do_begin_option ####################################################
# Begin a block of text that is ignored unless the option
# appears in options_set

def do_begin_option (s, args, line, comm_file):
  global options_stack
  global options_set

  print "do_begin_option: line: " + line
  print "options_set: " + str (options_set)

  if line in options_set:
    # Option is active. We push it onto the stack
    print "Pushing " + line + " onto options_stack"
    options_stack.insert(0, line)
  else:
    # Option is inactive.  Ignore all subseqent lines
    # until we get to an end command that matches our option.
    ignore_to_subcomm_end (s, args, line, comm_file, line)

#### do_begin_comm ######################################################

def do_begin_comm (s, args, line, comm_file):
  sub_commands = {"fotp": do_fotp_subcomm, "build": do_build_subcomm,
                  "absldr": do_absldr_subcomm}

  m = re.match(_comm_re, line)
  if m == None:
    print "Could not parse sub-command: " + line
  if m.group(1) not in sub_commands:
    print "Ignoring unrecognized sub-command: " + m.group(1)
    print "Ignoring everything to next end."
    ignore_to_subcomm_end(s, line, comm_file, "")
  else:
    sub_commands[m.group(1)](s, args, m.group(3), comm_file)


#### do_run_build_build #################################################
# ***CAUTION***
# When you do this you are instructing BUILD to
# OVERWRITE the system area.  If you do this to your
# running RK05 pack by mistake, you WILL make a mess
# and need to re-run mkos8 to re-make it.

def do_run_build_build (s, args, os8_spec, cd_spec):
  s.os8_send_cmd ("\$", "BUILD")
  s.os8_send_cmd ("LOAD OS/8: ", os8_spec)
  s.os8_send_cmd ("LOAD CD: ", cd_spec)


#### do_build_subcomm ###################################################

def do_build_subcomm (s, args, old_line, comm_file):
  os8_comm = "RU " + old_line
  if progmsg: print os8_comm
  s.os8_send_cmd ("\\.", os8_comm)
  
  for line in comm_file:
    line = basic_line_parse(s, args, line, comm_file)
    if line == None: continue

    m = re.match(_comm_re, line)
    if m == None:
      print "Ignoring mal-formed build sub-command: " + line
      continue

    build_sub = m.group(1)
    rest = m.group(3)
    if rest == None: rest = ""
    
    if build_sub not in _build_comm_regs:
      print "Unrecognized BUILD command: " + build_sub
      continue

    if build_sub == "end":
      if rest == "":
        print "Warning! end statement encountered inside build with no argument. Exiting build."
        return
      elif rest == "build": return
      else:
        print "Warning! Mismatched begin/end blocks. Encountered end: " + rest + "Exiting build."
        return
      
    build_re = _build_comm_regs[build_sub]

    if build_re != None:
      m2 = re.match(build_re, rest)
      if m2 == None:
        print "Ignoring mal-formed BUILD " + build_sub + " command: " + rest
        continue
    
      if build_sub == "BUILD":
        if m2.group(1) == None:
          print "Missing source of OS8.BN. Ignoring BUILD command."
          continue
        if m2.group(3) == None:
          print "Missing sorce of CD.BN. Ignoring BUILD command."
          continue
        if progmsg: print "calling do_run_build_build"
        do_run_build_build (s, args, m2.group(1), m2.group(3))
        continue

    comm = build_sub + " " + rest
    if progmsg: print "$ " + comm
    s.os8_send_cmd ("\$", comm)


#### do_fotp_subcomm ####################################################

def do_fotp_subcomm (s, args, old_line, comm_file):
  os8_comm = "RU " + old_line
  if progmsg: print os8_comm
  s.os8_send_cmd ("\\.", os8_comm)
  
  for line in comm_file:
    line = basic_line_parse(s, args, line, comm_file)
    if line == None: continue

    # Test for special case, "end" and act on it if present.
    m = re.match(_comm_re, line)
    if m != None and m.group(1) != None and m.group(1) != "" and m.group(1)  == "end":
      rest = m.group(3)
      if rest == None or rest == "":
        print "Warning! end statement encountered inside fotp with no argument."
      elif rest != "fotp":
        print "Warning! Mismatched begin/end blocks in fotp. Encountered end: " + rest
        
      if progmsg: print "End FOTP"
      s.os8_send_ctrl ('[')
      return

    m = re.match(_fotp_re, line)
    if m == None:
      print "Ignoring mal-formed fotp file spec: " + line
      continue

    comm = line
    if progmsg: print "* " + line
    s.os8_send_cmd ("\\*", line)

#### do_absldr_subcomm ####################################################
# A clone of do_fotp_subcom.  Can we find a way to merge the common code?

def do_absldr_subcomm (s, args, old_line, comm_file):
  os8_comm = "RU " + old_line
  if progmsg: print os8_comm
  s.os8_send_cmd ("\\.", os8_comm)
  
  for line in comm_file:
    line = basic_line_parse(s, args, line, comm_file)
    if line == None: continue

    # Test for special case, "end" and act on it if present.
    m = re.match(_comm_re, line)
    if m != None and m.group(1) != None and m.group(1) != "" and m.group(1)  == "end":
      rest = m.group(3)
      if rest == None or rest == "":
        print "Warning! end statement encountered inside absldr with no argument."
      elif rest != "absldr":
        print "Warning! Mismatched begin/end blocks in absldr. Encountered end: " + rest
        
      if progmsg: print "End ABSLDR"
      s.os8_send_ctrl ('[')
      return

    m = re.match(_absldr_re, line)
    if m == None:
      print "Ignoring mal-formed absldr file spec: " + line
      continue

    comm = line
    if progmsg: print "* " + line
    s.os8_send_cmd ("\\*", line)

#### ignore_to_subcomm_end #############################################

def ignore_to_subcomm_end (s, args, old_line, comm_file, end_str):
  global options_stack
  
  for line in comm_file:
    line = line.strip()
    print "Ignore: " + line
    
    m = re.match(_end_comm_re, line)
    if m == None: continue

    rest = m.group(1)
    if rest == None: rest = ""
    
    if rest == end_str: return


#### do_include_comm #####################################################
# Call run_system_script recursively on the file path provided.

def do_include_comm (s, args, line, comm_file):
  if not os.path.isfile(line):
    print "Could not find include file: " + line
  run_system_script (s, args, line)
    

#### do_end_comm ########################################################

def do_end_comm (s, args, line, comm_file):
  print "Unexpectedly encountered end command: " + line
  
    
#### run_system ########################################################
# Run a system command script
# Call parsers as needed for supported sub commands.
#
# Commands:
# mount <simh-dev> <image-file> [<option> ...]
#       option: must-exist | no-overwrite | read-only
# boot <simh-dev>
# os8 <command-line>
#       the rest of the line is passed verbatim to OS/8
# pal8 <pal-command line>
# done
# begin <sub-command> <os8-path>
# end <sub-command>
#
# Sub-commands:
# build, fotp
#
# Currently the run-script is hard-coded because of an old assumption
# about argument parsing for mkos8.

def run_system_script (s, args, filename):
# Strings, regexps, and command arrays used by run_system
  commands = {"mount": do_mount_comm, "boot": do_boot_comm ,
              "os8": do_os8_comm, "done": do_done_comm,
              "pal8": do_pal8_comm, "include": do_include_comm,
              "begin": do_begin_comm, "end": do_end_comm,
              "umount": do_umount_comm, "simh": do_simh_comm}

  try:
    comm_file = open(dirs.os8mo + filename, "r")
  except IOError:
    print filename + " not found."
    sys.exit(-1)

  for line in comm_file:
    line = basic_line_parse (s, args, line, comm_file)
    if line == None: continue
    
    m = re.match(_comm_re, line)
    if m == None:
      print "Ignoring command line: " + line
      continue

    if m.group(1) not in commands:
      print "Unrecognized command: " + m.group(1)
      continue

    print "Calling: " + m.group(1)
    commands[m.group(1)](s, args, m.group(3), comm_file)

#### testing ##############################################################
def run_testing (s, args):
  print "Testing!"
  s.send_cmd("att dt4 test.tu56")
  retval = s.change_dt_to_td()
  print str(retval)
  s.send_cmd("att td1 test.tu56")
  retval = s.change_td_to_dt()
  print str(retval)

  
#### main ##############################################################
# Program entry point.  Parses the command line and drives the above.

def main ():
  # Parse the command line
  allowed_acts = ["all", "bin", "src", "patch", "head", "v3f", "system", "testing"]
  do_all_acts = ["bin", "src"]    # Just do bin and src if act is "all".
  
  ap = argparser.ArgParser (allowed_acts)
  global progmsg
  global options_stack
  global options_set
  
  progmsg = not ap.args.verbose

  # Initialize our acts dict.
  acts = {}
  first_act = None
  for this in allowed_acts:
    acts[this] = False

  if ap.args.option != None:
    print "options:"
    for my_option in ap.args.option:
      options_set.extend(my_option)
      print my_option

  for act in ap.args.what:
    if act not in allowed_acts:
      print "Invalid act: " + act + " ignored."
      continue

    if first_act == None: first_act = act

    if act == "all":
      for this in do_all_acts:
        acts[this] = True
      break
    acts[act] = True

  # Log SIMH and OS/8 output to a file by default, but send it to the
  # console instead of the progress messages if -v was given using the
  # trick from https://stackoverflow.com/questions/21239338
  s = simh (dirs.build, True)
  s.set_logfile (open (dirs.log + 'mkos8-' + first_act + '.log', 'w') \
      if progmsg else os.fdopen (sys.stdout.fileno (), 'w', 0))

  if acts["bin"]: make_bin (s, ap.args)
  if acts["src"]: make_src (s, ap.args)
  if acts["patch"]: make_patch (s, ap.args)
  if acts["v3f"]: make_v3f (s, ap.args)
  if acts["head"]: run_system_script (s, ap.args,  "tc08.mkos8")
  if acts["system"]: run_system_script (s, ap.args, "v3f-control.mkos8")
  if acts["testing"]: run_testing (s, ap.args)
  
  s.quit ()
  if progmsg: print "Done!"


if __name__ == "__main__":
    main()
