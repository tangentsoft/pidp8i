/* pidp8i.c: PiDP-8/I additions to the PDP-8 simulator

   Copyright © 2015-2017 by Oscar Vermeulen, Ian Schofield, and
   Warren Young

   Permission is hereby granted, free of charge, to any person obtaining a
   copy of this software and associated documentation files (the "Software"),
   to deal in the Software without restriction, including without limitation
   the rights to use, copy, modify, merge, publish, distribute, sublicense,
   and/or sell copies of the Software, and to permit persons to whom the
   Software is furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be included in
   all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
   THE AUTHORS LISTED ABOVE BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
   DEALINGS IN THE SOFTWARE.

   Except as contained in this notice, the names of the authors above shall
   not be used in advertising or otherwise to promote the sale, use or other
   dealings in this Software without prior written authorization from those
   authors.
*/

#include "pidp8i.h"

#include "../gpio-common.h"

#include <dirent.h> // for USB stick searching


//// EXPORTED GLOBALS //////////////////////////////////////////////////

// truly terrible even for me - break out of sim and start new script in scp.c
int awfulHackFlag = 0;


//// set_pidp8i_led ////////////////////////////////////////////////////
// Sets the current state for a single LED at the given row and column
// on the PiDP-8/I PCB.  Also increments the LED on-count value for 
// that LED.
//
// You may say, "You can't just use the C postincrement operator here!
// Look at the assembly output!  You must use an atomic increment for
// this!"  And indeed, there is a big difference between the two
// methods: https://godbolt.org/g/0Qt0Ap
//
// The thing is, both structures referred to by pdis_* are fixed in RAM,
// and the two threads involved are arranged in a strict producer-and-
// consumer fashion, so it doesn't actually matter if pdis_update gets
// swapped for pdis_paint while we're halfway through an increment: we
// get a copy of the pointer to dereference here, so we'll finish our
// increment within the same structure we started with, even if
// pdis_update points at the other display structure before we leave.

static inline void set_pidp8i_led (display *pd, size_t row, size_t col)
{
    ++pd->on[row][col];
    pd->curr[row] |= 1 << col;
}


//// set_pidp8i_row_leds ///////////////////////////////////////////////
// Like set_pidp8i_led, except that it takes a 12-bit state value for
// setting all LEDs on the given row.  Because we copy the pdis_update
// pointer before making changes, if the display swap happens while
// we're working, we'll simply finish updating what has become the
// paint-from display, which is what you want; you don't want the
// updates spread over both displays.

static inline void set_pidp8i_row_leds (display *pd, size_t row,
        uint16 state)
{
    size_t *prow = pd->on[row];
    pd->curr[row] = state;
    for (size_t col = 0, mask = 1; col < NCOLS; ++col, mask <<= 1) {
        if (state & mask) ++prow[col];
    }
}


//// set_3_pidp8i_leds /////////////////////////////////////////////////
// Special case of set_pidp8i_row_leds for the DF and IF LEDs: we only
// pay attention to bits 12, 13, and 14 of the given state value,
// because SIMH's PDP-8 simulator shifts those 3 bits up there so it can
// simply OR these 3-bit registers with PC to produce a 15-bit extended
// address.
//
// We don't take a row parameter because we know which row they're on,
// but we do take a column parameter so we can generalize for IF & DF.

static inline void set_3_pidp8i_leds (display *pd, size_t col,
        uint16 state)
{
    static const int row = 7;       // DF and IF are on row 6
    size_t *prow = pd->on[row];
    size_t last_col = col + 3;
    pd->curr[row] |= state >> (12 - col);
    for (size_t mask = 1 << 12; col < last_col; ++col, mask <<= 1) {
        if (state & mask) ++prow[col];
    }
}


//// set_5_pidp8i_leds /////////////////////////////////////////////////
// Like set_3... but for the 5-bit SC register.  Because it's only used
// for that purpose, we don't need the col parameter.

static inline void set_5_pidp8i_leds (display *pd, uint16 state)
{
    static const int row = 6;       // SC is on row 6
    size_t *prow = pd->on[row];
    size_t last_col = 7;
    pd->curr[row] |= (state & 0x1f) << 2;
    for (size_t col = 2, mask = 1; col < last_col; ++col, mask <<= 1) {
        if (state & mask) ++prow[col];
    }
}


//// get_pidp8i_initial_max_skips //////////////////////////////////////
// Return the number of times we should skip updating the front panel
// LEDs the first time thru, to give the simulator time to settle.
// If we don't do this, the front panel LEDs can start out dim and
// slowly rise or they can overshoot and then take a while to recover
// with the IPS.

size_t get_pidp8i_initial_max_skips (size_t updates_per_sec)
{
    DEVICE *pthrot = find_dev ("INT-THROTTLE");
    if (pthrot) {
        REG *ptyper = find_reg ("THROT_TYPE", NULL, pthrot);
        REG *pvalr  = find_reg ("THROT_VAL", NULL, pthrot);
        if (ptyper && pvalr) {
            uint32 *ptype = ptyper->loc;
            uint32 *pval  =  pvalr->loc;
            size_t ips = 0;
            switch (*ptype) {
                case SIM_THROT_MCYC: ips = *pval * 1e6; break;
                case SIM_THROT_KCYC: ips = *pval * 1e3; break;
            }
            if (ips) {
                printf("PiDP-8/I initial throttle = %zu IPS\r\n", ips);
                return ips / updates_per_sec;
            }
        }
    }

    // No better idea, so give a plausible value for an unthrottled Pi 1
    return 200;
}


//// set_pidp8i_leds ///////////////////////////////////////////////////
// Given all of the PDP-8's internal registers that affect the front
// panel display, modify the GPIO thread's LED state values accordingly.
//
// Also update the LED brightness values based on those new states.

void set_pidp8i_leds (uint32 sPC, uint32 sMA, uint16 sMB,
    uint16 sIR, int32 sLAC, int32 sMQ, int32 sIF, int32 sDF,
    int32 sSC, int32 int_req, int Pause)
{
    // Bump the instruction count.  This should always be equal to the
    // Fetch LED's value, but integers are too cheap to get cute here.
    //
    // Note that we only update pdis_update directly once in this whole
    // process.  This is in case the display swap happens while we're
    // working: we want to finish work on the same display even though
    // it's now called the paint-from display, so it's consistent.
    display* pd = pdis_update;
    ++pd->inst_count;

    // Rows 0-4, easy cases: single-register LED strings
    set_pidp8i_row_leds (pd, 0, sPC);
    set_pidp8i_row_leds (pd, 1, sMA);
    set_pidp8i_row_leds (pd, 2, sMB);
    set_pidp8i_row_leds (pd, 3, sLAC & 07777);
    set_pidp8i_row_leds (pd, 4, sMQ);

#if 0   // debugging
    static time_t last = 0, now;
    if (time(&now) != last) {
        uint16* pcurr = pd->curr;
        printf("\r\nSET: [PC:%04o] [MA:%04o] [MB:%04o] [AC:%04o] [MQ:%04o]",
                pcurr[0], pcurr[1], pcurr[2], pcurr[3], pcurr[4]);
        last = now;
    }
#endif

    // Row 5a: instruction type column, decoded from high octal
    // digit of IR value
    pd->curr[5] = 0;
    uint16 inst_type = sIR & 07000;
    switch (inst_type) {
        case 00000: set_pidp8i_led (pd, 5, 11); break; // 000 AND
        case 01000: set_pidp8i_led (pd, 5, 10); break; // 001 TAD
        case 02000: set_pidp8i_led (pd, 5,  9); break; // 010 DCA
        case 03000: set_pidp8i_led (pd, 5,  8); break; // 011 ISZ
        case 04000: set_pidp8i_led (pd, 5,  7); break; // 100 JMS
        case 05000: set_pidp8i_led (pd, 5,  6); break; // 101 JMP
        case 06000: set_pidp8i_led (pd, 5,  5); break; // 110 IOT
        case 07000: set_pidp8i_led (pd, 5,  4); break; // 111 OPR 1 & 2
    }

    // Row 5b: set the Defer LED if...
    if ((inst_type <= 05000) &&  // it's a memory reference instruction
            (sIR & 00400)) {     // and indirect addressing flag is set
        set_pidp8i_led (pd, 5, 1);
    }

    // Row 5c: The Fetch LED is bumped once per CPU instruction, as is
    // Execute while we're not in STOP state.  They're set at different
    // times, but they're twiddled so rapidly that they both just become
    // a 50% blur in normal operation, so we don't make the CPU core set
    // these "on-time."  It just doesn't matter.
    extern int swStop, swSingInst;
    int running = !swStop && !swSingInst;
    if (running) set_pidp8i_led (pd, 5, 2);    // Execute
    set_pidp8i_led (pd, 5, 3);                 // Fetch

    // Row 6a: Remaining LEDs in upper right block
    pd->curr[6] = 0;
    if (running)           set_pidp8i_led (pd, 6, 7); // bump Run LED
    if (Pause)             set_pidp8i_led (pd, 6, 8); // bump Pause LED
    if (int_req & INT_ION) set_pidp8i_led (pd, 6, 9); // bump ION LED

    // Row 6b: The Step Count LEDs are also on row 6
    set_5_pidp8i_leds (pd, sSC);

    // Row 7: DF, IF, and Link.
    pd->curr[7] = 0;
    set_3_pidp8i_leds (pd, 9, sDF);
    set_3_pidp8i_leds (pd, 6, sIF);
    if (sLAC & 010000) set_pidp8i_led (pd, 7, 5);

    // If we're stopped or single-stepped, the display-swapping code
    // won't happen, so copy the above over to the paint-from version.
    extern int resumeFromInstructionLoopExit;
    if (!running || resumeFromInstructionLoopExit) {
        memcpy(pdis_paint, pdis_update, sizeof(struct display));
    }
}


//// mount_usb_stick_file //////////////////////////////////////////////
// Search for a PDP-8 media image in one of the Pi's USB auto-mount
// directories and attempt to ATTACH it to the simulator.

static void mount_usb_stick_file (int devNo, char *devCode)
{
    char    sFoundFile[CBUFSIZE] = { '\0' };
    char    sUSBPath[CBUFSIZE];     // will be "/media/usb0" etc
    char    fileExtension[4];       // will be ".RX" etc
    int     i, j;

    // Build expected file name extension from the first two characters of
    // the passed-in device code.
    fileExtension[0] = '.';                     // extension starts with a .
    strncpy (fileExtension + 1, devCode, 2);    // extension is PT, RX, RL etc
    fileExtension[2] = '\0';                    // chop off device number

    // Forget the prior file attached to this PDP-8 device.  The only reason
    // we keep track is so we don't have the same media image file attached
    // to both devices of a given type we support.  That is, you can't have
    // a given floppy image file attached to both RX01 drives, but you *can*
    // repeatedly re-ATTACH the same floppy image to the first RX01 drive.
    static char mountedFiles[8][CBUFSIZE];
    mountedFiles[devNo][0] = '\0';

    for (i = 0; i < 8 && sFoundFile[0] == '\0'; ++i) {
        // search all 8 USB mount points, numbered 0-7
        snprintf (sUSBPath, sizeof (sUSBPath), "/media/usb%d", i);
        DIR *pDir = opendir (sUSBPath);
        if (pDir) {
            struct dirent* pDirent;
            while ((pDirent = readdir (pDir)) != 0) { // search all files in directory
                if (strstr (pDirent->d_name, fileExtension)) {
                    snprintf (sFoundFile, sizeof (sFoundFile), "%s/%s",
                            sUSBPath, pDirent->d_name);
                    for (j = 0; j < 7; ++j) {
                        if (strncmp (mountedFiles[j], sFoundFile, CBUFSIZE) == 0) {
                            break;  // already mounted; skip next
                        }
                    }
                    if (j == 7) {
                        // Media image file is not already mounted, so leave while
                        // loop with path set to mount it
                        break;
                    }
                    else {
                        // It's mounted, so forget its path, else we will stop
                        // searching the other USB mount points
                        sFoundFile[0] = '\0';
                    }
                }
            }

            closedir (pDir);
        }
        else {
            // Not a Pi or the USB auto-mounting software isn't installed
            printf ("\r\nCannot open %s: %s\r\n", sUSBPath, strerror (errno));
            return;
        }
    }

    if (sFoundFile[0]) {            // no file found, exit
        if (access (sFoundFile, R_OK) == 0) {
            if (attach_cmd ((int32) 0, sFoundFile) == SCPE_OK) {   // issue ATTACH command
                // add file to mount list
                strncpy (mountedFiles[devNo], sFoundFile, CBUFSIZE);
                printf ("\r\nMounted %s %s\r\n", devCode, mountedFiles[devNo]);
            }
            else {
                printf ("\r\nSIMH error mounting %s\r\n", devCode);
            }
        }
        else {
            printf ("\r\nCannot read medium image %s from USB: %s\r\n",
                    sFoundFile, strerror (errno));
        }
    }
    else {
        printf ("\r\nNo unmounted %s file found\r\n", devCode);
    }
}


//// handle_sing_step //////////////////////////////////////////////////
// Handle SING_STEP combinations as nonstandard functions with respect
// to a real PDP-8, since SIMH doesn't try to emulate the PDP-8's
// single-stepping mode — not to be confused with single-instruction
// mode, which SIMH *does* emulate — so the SING_STEP switch is free
// for our nonstandard uses.
//
// This is separate from handle_flow_control_switches only because
// there are so many cases here that it would obscure the overall flow
// of our calling function to do all this there.

static pidp8i_flow_t handle_sing_step (int closed)
{
    // If SING_STEP is open, we do nothing here except reset the single-shot
    // flag if it was set.
    static int single_shot = 0;
    if (!closed) {
        single_shot = 0;
        return pft_normal;
    }

    // There are two sets of SING_STEP combos: first up are those where the
    // other switches involved have to be set already, and the function is
    // triggered as soon as SING_STEP closes.  These are functions we don't
    // want re-executing repeatedly while SING_STEP remains closed.
    if (single_shot == 0) {
        // SING_STEP switch was open last we knew, and now it's closed, so
        // set the single-shot flag.
        single_shot = 1;

        // 1. Convert DF switch values to a device number, which
        // we will map to a PDP-8 device type, then attempt to
        // ATTACH some unmounted medium from USB to that device
        //
        // We treat DF == 0 as nothing to mount, since we use
        // SING_STEP for other things, so we need a way to
        // decide which meaning of SING_STEP to take here.
        //
        // The shift by 9 is how many non-DF bits are below
        // DF in switchstatus[1]
        //
        // The bit complement is because closed DF switches show
        // as 0, because they're dragging the pull-up down, but
        // we want those treated as 1s, and vice versa.
        uint16_t css1 = ~switchstatus[1]; 
        int swDevice = (css1 & SS1_DF_ALL) >> 9;
        if (swDevice) {
            char swDevCode[4] = { '\0' };
            switch (swDevice) {
                case 1: strcpy (swDevCode, "ptr"); break; // PTR paper tape reader
                case 2: strcpy (swDevCode, "ptp"); break; // High speed paper tape punch
                case 3: strcpy (swDevCode, "dt0"); break; // TC08 DECtape (#8 is first!)
                case 4: strcpy (swDevCode, "dt1"); break;
                case 5: strcpy (swDevCode, "rx0"); break; // RX8E (8/e peripheral!)
                case 6: strcpy (swDevCode, "rx1"); break;
                case 7: strcpy (swDevCode, "rl0"); break; // RL8A
            }
            if (swDevCode[0]) mount_usb_stick_file (swDevice, swDevCode);
        }

        // 2. Do the same with IF, except that the switch value
        // is used to decide which boot script to restart with via
        // SIMH's DO command.
        //
        // The shift value of 6 is because the IF switches are 3
        // down from the DF switches above.
        int swScript = (css1 & SS1_IF_ALL) >> 6;
        if (swScript) {
            // build filename from IF value
            char sScript[256];
            snprintf (sScript, sizeof (sScript), "@BOOTDIR@/%d.script", swScript);
            printf ("\r\n\nRebooting %s\r\n\r\n", sScript);
            awfulHackFlag = swScript;   // this triggers a do command after leaving the simulator run.
            return pft_halt;
        }
    } // end if single-shot flag clear
    else {
        // Now handle the second set of SING_STEP special-function
        // combos, being those where the switches can be pressed in any
        // order, so that we take action when the last one of the set
        // closes, no matter which one that is.  These immediately exit
        // the SIMH instruction interpreter, so they won't re-execute
        // merely because the human isn't fast enough to lift his finger
        // by the time the next iteration of that loop starts.

        // 3. Scan for host poweroff command (Sing_Step + Sing_Inst + Stop)
        if ((switchstatus[2] & (SS2_S_INST | SS2_STOP)) == 0) {
            printf ("\r\nShutdown\r\n\r\n");
            awfulHackFlag = 8;  // this triggers an exit command after leaving the simulator run.
            if (spawn_cmd (0, "sudo /bin/systemctl poweroff") != SCPE_OK) {
                printf ("\r\n\r\npoweroff failed\r\n\r\n");
            }
            return pft_halt;
        }

        // 4. Scan for host reboot command (Sing_Step + Sing_Inst + Start)
        if ((switchstatus[2] & (SS2_S_INST | SS2_START)) == 0) {
            printf ("\r\nReboot\r\n\r\n");
            awfulHackFlag = 8;      // this triggers an exit command after leaving the simulator run.
            if (spawn_cmd (0, "sudo /bin/systemctl reboot") != SCPE_OK) {
                printf ("\r\n\r\nreboot failed\r\n\r\n");
            }
            return pft_halt;
        }

        #if 0
        // These combos once meant something, but no longer do.  If you
        // reassign them, think carefully whether they should continue to
        // be handled here and not above in the "if" branch.  If nothing
        // prevents your function from being re-executed while SING_STEP
        // remains closed and re-execution would be bad, move the test
        // under the aegis of the single_shot flag.

        // 5. Sing_Step + Sing_Inst + Load Add
        if ((switchstatus[2] & (SS2_S_INST | SS2_L_ADD)) == 0) { }

        // 6. Sing_Step + Sing_Inst + Deposit
        if ((switchstatus[2] & (SS2_S_INST | SS2_DEP)) == 0) { }
        #endif
    }

    return pft_normal;
}


//// handle_flow_control_switches //////////////////////////////////////
// Process all of the PiDP-8/I front panel switches that can affect the
// flow path of the PDP-8 simulator's instruction interpretation loop,
// returning a code telling the simulator our decision.
//
// The simulator passes in pointers to PDP-8 registers we may modify as
// a side effect of handling these switches.

pidp8i_flow_t handle_flow_control_switches (uint16* pM,
    uint32 *pPC, uint32 *pMA, int32 *pMB, int32 *pLAC, int32 *pIF,
    int32 *pDF, int32* pint_req)
{
    // Exit early if the blink thread has not attached itself to the GPIO
    // peripheral in the Pi, since that means we cannot safely interpret the
    // data in the switchstatus array.  This is especially important on
    // non-Pi hosts, since switchstatus will remain zeroed, which we would
    // interpret as "all switches are pressed!", causing havoc.
    //
    // It would be cheaper for our caller to check this for us and skip the
    // call, but there's no good reason to expose such implementations
    // details to it.  We're trying to keep the PDP-8 simulator's CPU core
    // as free of PiDP-8/I details as is practical.
    if (!pidp8i_gpio_present) return pft_normal;

    // Handle the nonstandard SING_STEP + X combos, some of which halt
    // the processor.
    if (handle_sing_step ((switchstatus[2] & SS2_S_STEP) == 0) == pft_halt) {
        return pft_halt;
    }

    // Check for SING_INST switch close...
    extern int swSingInst;
    if (((switchstatus[2] & SS2_S_INST) == 0) && (swSingInst == 0)) {
        // Put the processor in single-instruction mode until we get a
        // CONT or START switch closure.  Technically this is wrong
        // according to DEC's docs: we're supposed to finish executing
        // the next instruction before we "clear the RUN flip-flop" in
        // DEC terms, whereas we're testing these switches before we
        // fetch the next instruction.  Show me how it matters, and
        // I'll fix it. :)
        swSingInst = 1;
    }

    // ...and SING_INST switch open
    extern int swStop;
    if (swSingInst && (switchstatus[2] & SS2_S_INST)) {
        swSingInst = 0;
        swStop = 1;     // still stopped on leaving SING_INST mode
    }

    // Check for START switch press...
    static int swStart = 0;
    if (((switchstatus[2] & SS2_START) == 0) && (swStart == 0)) {
        // Reset the CPU.
        extern DEVICE cpu_dev;
        extern t_stat cpu_reset (DEVICE *);
        cpu_reset (&cpu_dev);

        // DEC's docs say there are a few additional things START does
        // that cpu_reset() doesn't do for us.
        //
        // Don't need to do anything with MA and IR, as SIMH does that
        // shortly after this function returns.
        *pLAC = *pMB = 0;

        // cpu_reset() does its thing to the saved_* register copies
        // in a few cases, but we need it to happen to the "real"
        // registers instead, since our STOP/START behavior doesn't
        // make use of saved_*.
        REG* pibr = find_reg ("IB", NULL, &cpu_dev);
        int32* pIB = pibr ? pibr->loc : 0 /* force segfault on err */ ;
        *pIB = *pIF;

        // Reset our switch flags, too
        swStop = 0;            // START cancels STOP mode
        swSingInst = 0;        // allow SING INST mode re-entry
        swStart = 1;           // make it single-shot

#if 0   // debugging
        printf("\r\nSTART: [DF:%o] [IF:%o] [IB:%o] [PC:%04o] "
                "[MA:%04o] [MB:%04o] [L:%d] [AC:%04o]",
                (*pDF >> 12), (*pIF >> 12), (*pIB >> 12), (*pPC & 07777),
                *pMA, *pMB, !!(*pLAC & 010000), *pLAC & 07777);
#endif
    }

    // ...and START switch release
    if (swStart && (switchstatus[2] & SS2_START)) {
        swStart = 0;
    }

    // Check for CONT switch press...
    static int swCont = 0;
    extern int resumeFromInstructionLoopExit;
    if ((((switchstatus[2] & SS2_CONT) == 0) && (swCont == 0)) ||
            resumeFromInstructionLoopExit) {
        // The initial CONT press is special: how we handle it
        // depends on the processor's state.
        //
        // FIXME: Are we handling MB correctly? [973271ae36]
        swCont = 1;                 // make it single-shot
        resumeFromInstructionLoopExit = 0;
        if (swSingInst) {
            // On the initial CONT press while in SING_INST mode, run
            // one instruction only.
            return pft_normal;
        }
        else if (swStop) {
            // We were HLTed or STOPped, so CONT returns us to
            // free-running mode.
            swStop = 0;

#if 0   // debugging
            printf("\r\nCONT: [DF:%o] [IF:%o] [PC:%04o] "
                    "[MA:%04o] [MB:%04o] [L:%d] [AC:%04o]",
                    (*pDF >> 12), (*pIF >> 12), (*pPC & 07777),
                    *pMA, *pMB, !!(*pLAC & 010000), *pLAC & 07777);
#endif
        }
        // else, CONT has no effect in this state
    }

    // ...and CONT switch release
    if (swCont && (switchstatus[2] & SS2_CONT)) {
        swCont = 0;
    }

    // Check for LOAD_ADD switch press.  The only reason we bother
    // making it single-shot is in case debugging is enabled.
    // Otherwise, it matters not how long the slow human holds this
    // swithc down, and thus how often we apply the values: all else
    // but our printf() here is idempotent.
    static int swLAdd = 0;
    if ((swLAdd == 0) && (switchstatus[2] & SS2_L_ADD) == 0) {
        // Copy SR into PC.  Have to flip the bits because GPIO gives
        // 0 for a closed switch and 1 for open, opposite what we want.
        *pPC = (~switchstatus[0]) & 07777;
                               
        // Copy DF switch settings to DF register
        //
        // The shift is because the DF positions inside the switchstatus[1]
        // register happen to be 3 bit positions off of where we want them
        // in DF here: we want to be able to logically OR PC and DF to make
        // 15-bit data access addresses.
        //
        // We complement the bits here for the same reason we did above
        uint16_t css1 = ~switchstatus[1]; 
        *pDF = (css1 & SS1_DF_ALL) << 3;

        // Do the same for IF.  The only difference comes from the fact
        // that IF is the next 3 bits down in switchstatus[1].
        *pIF = (css1 & SS1_IF_ALL) << 6;

#if 0   // debugging
        printf("\r\nL_ADD: [DF:%o] [IF:%o] [PC:%04o] "
                "[MA:%04o] [MB:%04o] [L:%d] [AC:%04o]",
                (*pDF >> 12), (*pIF >> 12), (*pPC & 07777),
                *pMA, *pMB, !!(*pLAC & 010000), *pLAC & 07777);
#endif
        swLAdd = 1;                 // make it single-shot
    }

    // ...and L_ADD switch release
    if (swLAdd && (switchstatus[2] & SS2_L_ADD)) {
        swLAdd = 0;
    }

    // Check for DEP switch press...
    static int swDep = 0;
    if (((switchstatus[2] & SS2_DEP) == 0) && (swDep == 0)) {
        uint16 sSR = (~switchstatus[0]) & 07777; // bit flip justified above
        *pPC = *pPC & 07777;  // sometimes high bits get set; squish 'em

#if 0   // debugging
        printf("\r\nDEP: [IF:%o] [PC:%04o] [SR:%04o]",
                (*pIF >> 12), *pPC, sSR);
#endif

        /* ??? in 66 handbook: strictly speaking, SR goes into AC,
           then AC into MB. Does it clear AC afterwards? If not, needs fix */
        pM[*pPC] = sSR;             // FIXME: shouldn't we use IF/DF here?
        *pMB = sSR;
        *pMA = *pPC & 07777;        // MA trails PC on FP; FIXME: OR in IF?
        *pPC = (*pPC + 1) & 07777;  // increment PC
        swDep = 1;                  // make it single-shot
    }

    // ...and DEP switch release
    if (swDep && (switchstatus[2] & SS2_DEP)) {
        swDep = 0;
    }

    // Check for EXAM switch press...
    static int swExam = 0;
    if (((switchstatus[2] & SS2_EXAM) == 0) && (swExam == 0)) {
        *pMB = pM[*pPC];
        *pMA = *pPC & 07777;          // MA trails PC on FP
        *pPC = (*pPC + 1) & 07777;    // increment PC
        swExam = 1;                   // make it single-shot
    }

    // ...and EXAM switch release
    if (swExam && (switchstatus[2] & SS2_EXAM)) {
        swExam = 0;
    }

    // Check for STOP switch press.  No "and release" because we get out of
    // STOP mode with START or CONT, not by releasing STOP, and while in
    // STOP mode, this switch's function is idempotent.
    if (!swStop && ((switchstatus[2] & SS2_STOP) == 0)) {
        swStop = 1;

#if 0   // debugging
            printf("\r\nSTOP: [DF:%o] [IF:%o] [PC:%04o] "
                    "[MA:%04o] [MB:%04o] [L:%d] [AC:%04o]",
                    (*pDF >> 12), (*pIF >> 12), (*pPC & 07777),
                    *pMA, *pMB, !!(*pLAC & 010000), *pLAC & 07777);
#endif
    }

    // If any of the above put us into STOP or SING_INST mode, go no
    // further.  In particular, fetch no more instructions, and do not
    // touch PC!  The only way to get un-stuck is CONT or STOP.
    return (swStop || swSingInst) ? pft_stop : pft_normal;
}


//// get_switch_register ///////////////////////////////////////////////
// Return the current contents of the switch register

int32 get_switch_register (void)
{
    return switchstatus[0] ^ 07777;
}
