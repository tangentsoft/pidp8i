/*
 * gpio-common.c: functions common to both gpio.c and gpio-nls.c
 *
 * Copyright Â© 2015-2017 Oscar Vermeulen and Warren Young
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS LISTED ABOVE BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the names of the authors above shall
 * not be used in advertising or otherwise to promote the sale, use or other
 * dealings in this Software without prior written authorization from those
 * authors.
 *
 * www.obsolescenceguaranteed.blogspot.com
 * 
 * The only communication with the main program (simh):
 * - external variable ledstatus is read to determine which leds to light.
 * - external variable switchstatus is updated with current switch settings.
*/

#include "gpio-common.h"

#include "config.h"

#include <pthread.h>
#include <sys/file.h>
#include <sys/time.h>

#include <ctype.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#ifdef HAVE_TIME_H
#	include <time.h>
#endif

#define BLOCK_SIZE (4*1024)


// Flag set after we successfully init the GPIO mechanism.  While this
// is false, the rest of the code knows not to expect useful values for
// LED and switch states.  It is also useful as a cross-thread signal,
// since merely starting the blink() thread doesn't tell you whether it
// managed to lock the GPIO device.
uint8_t pidp8i_gpio_present;

struct bcm2835_peripheral gpio;	// needs initialisation


// A constant meaning "indeterminate milliseconds", used for error
// returns from ms_time() and for the case where the switch is in the
// stable state in the switch_state array.
static const ms_time_t na_ms = (ms_time_t)-1;


// Adjust columns to scan based on whether the serial mod was done, as
// that affects the free GPIOs for our use, and how the PCB connects
// them to the LED matrix.
#ifdef PCB_SERIAL_MOD
uint8_t cols[] = {13, 12, 11,    10, 9, 8,    7, 6, 5,    4, 3, 2};
#else
uint8_t cols[] = {13, 12, 11,    10, 9, 8,    7, 6, 5,    4, 15, 14};
#endif

uint8_t ledrows[] = {20, 21, 22, 23, 24, 25, 26, 27};

uint8_t rows[] = {16, 17, 18};

// Array sizes.  Must be declared twice because we need to export them,
// and C doesn't have true const, as C++ does.
#define NCOLS    (sizeof(cols)    / sizeof(cols[0]))
#define NLEDROWS (sizeof(ledrows) / sizeof(ledrows[0]))
#define NROWS    (sizeof(rows)    / sizeof(rows[0]))
const size_t ncols    = NCOLS;
const size_t nledrows = NLEDROWS;
const size_t nrows    = NROWS;

// The public switch and LED API: other threads poke values into
// ledstatus to affect our GPIO LED pin driving loop and read values
// from switchstatus to discover our current published value of the
// switch states.  The latter may differ from the *actual* switch
// states due to the debouncing procedure.
uint16_t switchstatus[NROWS];	// bitfield: sparse nrows x ncols switch matrix
uint16_t ledstatus[NLEDROWS];	// bitfield: sparse nledrows x ncols LED matrix

// Time-delayed reaction to switch changes to debounce the contacts.
// This is especially important with the incandescent lamp simulation
// feature enabled since that speeds up the GPIO scanning loop, making
// it more susceptible to contact bounce.
struct switch_state {
	// switch state currently reported via switchstatus[]
	int stable_state;

	// ms the switch state has been != stable_state, or na_ms
	// if it is currently in that same state
	ms_time_t last_change;		
};
static struct switch_state gss[NROWS][NCOLS];
int gss_initted = 0;
static const ms_time_t debounce_ms = 50;	// time switch state must remain stable

// Name of GPIO memory-mapped device
static const char* gpio_mem_dev = "/dev/gpiomem";


// Exposes the physical address defined in the passed structure
int map_peripheral(struct bcm2835_peripheral *p)
{
	// Open the GPIO device
	if ((p->mem_fd = open(gpio_mem_dev, O_RDWR|O_SYNC) ) < 0) {
#ifdef DEBUG
		printf("Failed to open %s: %s\n", gpio_mem_dev, strerror(errno));
		puts("Disabling PiDP-8/I front panel functionality.");
#endif
		return -1;
	}

	// Attempt to lock it.  If we can't, another program has it locked,
	// so we shouldn't keep running; it'll just end in tears.
	if (flock(p->mem_fd, LOCK_EX | LOCK_NB) < 0) {
		if (errno == EWOULDBLOCK) {
			printf("Failed to lock %s.  Only one PiDP-8/I\n", gpio_mem_dev);
			puts("program can be running at a given time.");
		}
		else {
			printf("Failed to lock %s: %s\n", gpio_mem_dev, strerror(errno));
			puts("Only one PiDP-8/I program can be running at a given time.");
		}
		return -1;
	}

	// Map the GPIO peripheral into our address space
	if ((p->map = mmap(
			NULL, BLOCK_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED,
			p->mem_fd,
			p->addr_p)) == MAP_FAILED) {
		perror("mmap");
		return -1;
	}

	// Success!
	p->addr = (volatile unsigned int *)p->map;
	pidp8i_gpio_present = 1;
	return 0;
}


void unmap_peripheral(struct bcm2835_peripheral *p)
{
	// Unwind the map_peripheral() steps in reverse order
	if (pidp8i_gpio_present) {
		if (p->mem_fd > 0) {
			if (p->map) munmap(p->map, BLOCK_SIZE);
			flock(p->mem_fd, LOCK_UN);
			close(p->mem_fd);
		}
		pidp8i_gpio_present = 0;
	}
}


unsigned bcm_host_get_peripheral_address(void)		// find Pi's GPIO base address
{
	unsigned address = ~0;
	FILE *fp = fopen("/proc/device-tree/soc/ranges", "rb");
	if (fp)
	{	unsigned char buf[4];
		fseek(fp, 4, SEEK_SET);
		if (fread(buf, 1, sizeof buf, fp) == sizeof buf)
			address = buf[0] << 24 | buf[1] << 16 | buf[2] << 8 | buf[3] << 0;
		fclose(fp);
	}

	return address == ~0 ? 0x20000000 : address;
}


void sleep_ns(ns_time_t ns)
{
	struct timespec ts = { 0, ns };
#if defined(HAVE_CLOCK_NANOSLEEP)
	clock_nanosleep(CLOCK_REALTIME, 0, &ts, NULL);
#elif defined(HAVE_NANOSLEEP)
	nanosleep(&ts, NULL);
#elif defined(HAVE_USLEEP)
	usleep(ns / 1000);
#else
#	error Cannot build GPIO controller without high-res "sleep" function!
#endif
}


// Like time(2) except that it returns milliseconds since the Unix epoch
ms_time_t ms_time(ms_time_t* pt)
{
	struct timeval tv;
	if (gettimeofday(&tv, 0) == 0) {
		ms_time_t t = (ms_time_t)(tv.tv_sec / 1000.0 + tv.tv_usec * 1000.0);
		if (pt) *pt = t;
		return t;
	}
	else {
		return na_ms;
	}
}


// Save given switch state ss into the exported switchstatus bitfield
// so the simulator core will see it.  (Constrast the gss matrix,
// which holds our internal view of the unstable truth.)
static void report_ss(int row, int col, int ss,
		struct switch_state* pss)
{
	pss->stable_state = ss;
	pss->last_change = na_ms;

	int mask = 1 << col;
	if (ss) switchstatus[row] |=  mask;
	else    switchstatus[row] &= ~mask;

	#ifdef DEBUG
		printf("%cSS[%d][%02d] = %d  ", gss_initted ? 'N' : 'I', row, col, ss);
	#endif
}


// Given the state of the switch at (row,col), work out if this requires
// a change in our exported switch state.
void debounce_switch(int row, int col, int ss, ms_time_t now_ms)
{
	struct switch_state* pss = &gss[row][col];

	if (!gss_initted) {
		// First time thru, so set this switch's module-global and
		// exported state to its defaults now that we know the switch's
		// initial state.
		report_ss(row, col, ss, pss);
	}
	else if (ss == pss->stable_state) {
		// This switch is still/again in the state we consider "stable",
		// which we are reporting in our switchstatus bitfield.  Reset
		// the debounce timer in case it is returning to its stable
		// state from a brief blip into the other state.
		pss->last_change = na_ms;
	}
	else if (pss->last_change == na_ms) {
		// This switch just left what we consider the "stable" state, so
		// start the debounce timer.
		pss->last_change = now_ms;
	}
	else if ((now_ms - pss->last_change) > debounce_ms) {
		// Switch has been in the new state long enough for the contacts
		// to have stopped bouncing: report its state change to outsiders.
		report_ss(row, col, ss, pss);
	}
	// else, switch was in the new state both this time and the one prior,
	// but it hasn't been there long enough to report it
}


// Write a configuration string tag.
static const char* pi_type(int p)
{
	if (p == 0x20200000) {
		return "pi1+";
	}
	else {
		FILE* fp = fopen("/proc/device-tree/model", "r");
		if (fp) {
			static char ac[60];
			if (fgets(ac, sizeof(ac), fp) && (strlen(ac) > 20)) {
				if (strstr(ac, "Raspberry Pi ") == ac) {
					int series = atoi(ac + 13);
					char model = 'x';
					char* pm = strstr(ac, " Model ");
					if (pm) model = tolower(pm[7]);
					snprintf(ac, sizeof(ac), "pi%d%c", series, model);
					return ac;
				}
			}
			return "pi2+";
		}
	}

	return 0;		// not a Pi
}


// The GPIO thread entry point: initializes GPIO and then calls
// the blink_core() implementation linked to this program.

void *blink(void *terminate)
{
	// Find GPIO address (it varies by Pi model)
	gpio.addr_p = bcm_host_get_peripheral_address() + 0x200000;

	// Set thread to real time priority
	struct sched_param sp;
	sp.sched_priority = 4;	// not high, just above the minimum of 1
	int rt = pthread_setschedparam(pthread_self(), SCHED_FIFO, &sp) == 0;

	// Map the GPIO peripheral, but hold off exiting if it fails, until
	// we report its absence in the config line.
	int mapped = map_peripheral(&gpio) == 0;

	// Tell the user about our configuration, succinctly
	const char* pt = pi_type(mapped ? gpio.addr_p : 0);
	printf(
		"PiDP-8/I @VERSION@ [%s] [@LED_DRIVER_MODULE@ls] [%spcb]%s"
#ifdef DEBUG
		" [debug]"
#endif
		"%s",
		pt ? pt : "cake",		// pt == 0 == not a Pi
		pt ? 
#ifdef PCB_SERIAL_MOD
			"ser" : 
#else
			"std" : 
#endif
			"no",
		mapped ? " [gpio]" : "",
		rt     ? " [rt]" : ""
	);

	// Hand off control to the blink_core() variant linked to this
	// program: either the new incandescent lamp simulator or the old
	// stock version.
	if (mapped) {
		// initialise GPIO (all pins used as inputs, with pull-ups enabled on cols)
		//  INSERT CODE HERE TO SET GPIO 14 AND 15 TO I/O INSTEAD OF ALT 0.
		//  AT THE MOMENT, USE "sudo ./gpio mode 14 in" and "sudo ./gpio mode 15 in". "sudo ./gpio readall" to verify.
		#define pgpio (&gpio)
		int i;
		for (i = 0; i <nledrows; i++) {     // Define ledrows as input
			INP_GPIO(ledrows[i]);
			GPIO_CLR = 1 << ledrows[i];     // so go to Low when switched to output
		}
		for (i = 0; i < ncols; i++) {       // Define cols as input
			INP_GPIO(cols[i]);
		}
		for (i = 0; i < nrows; i++) {       // Define rows as input
			INP_GPIO(rows[i]);
		}

		// BCM2835 ARM Peripherals PDF p 101 & elinux.org/RPi_Low-level_peripherals#Internal_Pull-Ups_.26_Pull-Downs
		GPIO_PULL = 2;  // pull-up
		usleep(1);  // must wait 150 cycles
#ifdef PCB_SERIAL_MOD
		GPIO_PULLCLK0 = 0x03ffc; // selects GPIO pins 2..13 (frees up serial port on 14 & 15)
#else
		GPIO_PULLCLK0 = 0x0fff0; // selects GPIO pins 4..15 (assumes we avoid pins 2 and 3!)
#endif
		usleep(1);
		GPIO_PULL = 0; // reset GPPUD register
		usleep(1);
		GPIO_PULLCLK0 = 0; // remove clock
		usleep(1); // probably unnecessary

		// BCM2835 ARM Peripherals PDF p 101 & elinux.org/RPi_Low-level_peripherals#Internal_Pull-Ups_.26_Pull-Downs
		GPIO_PULL = 1;  // pull-down to avoid ghosting (dec2015)
		usleep(1);  // must wait 150 cycles
		GPIO_PULLCLK0 = 0x0ff00000; // selects GPIO pins 20..27
		usleep(1);
		GPIO_PULL = 0; // reset GPPUD register
		usleep(1);
		GPIO_PULLCLK0 = 0; // remove clock
		usleep(1); // probably unnecessary

		// BCM2835 ARM Peripherals PDF p 101 & elinux.org/RPi_Low-level_peripherals#Internal_Pull-Ups_.26_Pull-Downs
		GPIO_PULL = 0;  // no pull-up no pull down just float
		usleep(1);  // must wait 150 cycles
		GPIO_PULLCLK0 = 0x070000; // selects GPIO pins 16..18
		usleep(1);
		GPIO_PULL = 0; // reset GPPUD register
		usleep(1);
		GPIO_PULLCLK0 = 0; // remove clock
		usleep(1); // probably unnecessary

		extern void blink_core(struct bcm2835_peripheral*, int* terminate);
		blink_core(&gpio, (int*)terminate);
	}

    // blink_core() leaves all cols, rows, ledrows are set to input, and
	// it's safe to leave them in that state.  No need to de-init GPIO.

	gss_initted = 0;
	return mapped ? 0 : (void*)-1;
}
