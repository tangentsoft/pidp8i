/*
 * gpio-common.c: functions common to both gpio.c and gpio-nls.c
 *
 * Copyright Â© 2015-2017 Oscar Vermeulen and Warren Young
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS LISTED ABOVE BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the names of the authors above shall
 * not be used in advertising or otherwise to promote the sale, use or other
 * dealings in this Software without prior written authorization from those
 * authors.
 *
 * www.obsolescenceguaranteed.blogspot.com
 * 
 * This is part of the GPIO thread, which communicates with the
 * simulator's main thread via *pdis_update and switchstatus[].
 * All of this module's other external interfaces are only called
 * by the other gpio-* modules, from the GPIO thread.
*/

#include "gpio-common.h"

#include "config.h"

#include "PDP8/pidp8i.h"

#include <pthread.h>
#include <sys/file.h>
#include <sys/time.h>

#include <ctype.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#ifdef HAVE_TIME_H
#   include <time.h>
#endif

#define BLOCK_SIZE (4*1024)


//// GLOBALS ///////////////////////////////////////////////////////////

// Flag set after we successfully init the GPIO mechanism.  While this
// is false, the rest of the code knows not to expect useful values for
// LED and switch states.  It is also useful as a cross-thread signal,
// since merely starting the blink() thread doesn't tell you whether it
// managed to lock the GPIO device.
uint8_t pidp8i_gpio_present;

struct bcm2835_peripheral gpio; // needs initialisation
#define pgpio (&gpio)


// A constant meaning "indeterminate milliseconds", used for error
// returns from ms_time() and for the case where the switch is in the
// stable state in the switch_state array.
static const ms_time_t na_ms = (ms_time_t)-1;


// Adjust columns to scan based on whether the serial mod was done, as
// that affects the free GPIOs for our use, and how the PCB connects
// them to the LED matrix.
#ifdef PCB_SERIAL_MOD
uint8_t cols[NCOLS] = {13, 12, 11,    10, 9, 8,    7, 6, 5,    4, 3, 2};
#else
uint8_t cols[NCOLS] = {13, 12, 11,    10, 9, 8,    7, 6, 5,    4, 15, 14};
#endif

uint8_t ledrows[NLEDROWS] = {20, 21, 22, 23, 24, 25, 26, 27};

uint8_t rows[NROWS] = {16, 17, 18};


// Current switch states, as reported by the debouncing algorithm.  Set
// from the GPIO thread to control the SIMH CPU thread.
uint16_t switchstatus[NROWS];

// Double-buffered LED display brightness values.  The update-to copy is
// modified by the SIMH CPU thread as it executes instructions, and the
// paint-from copy is read by the gpio-*.c module in its "set LEDs"
// loop.  When the GPIO thread is finished with the paint-from copy, it
// zeroes it and swaps it for the current "update-to" copy, giving the
// CPU thread a blank slate, and giving the GPIO thread a stable set of
// LED "on" time values to work with.
static display display_bufs[2];
display* pdis_update = display_bufs + 0;    // exported to SIMH CPU thread
display* pdis_paint  = display_bufs + 1;    // exported to gpio-*.c


// Time-delayed reaction to switch changes to debounce the contacts.
// This is especially important with the incandescent lamp simulation
// feature enabled since that speeds up the GPIO scanning loop, making
// it more susceptible to contact bounce.
struct switch_state {
    // switch state currently reported via switchstatus[]
    int stable_state;

    // ms the switch state has been != stable_state, or na_ms
    // if it is currently in that same state
    ms_time_t last_change;      
};
static struct switch_state gss[NROWS][NCOLS];
static int gss_initted = 0;
static const ms_time_t debounce_ms = 50;    // time switch state must remain stable

// Name of GPIO memory-mapped device
static const char* gpio_mem_dev = "/dev/gpiomem";


// STOP and SING_INST switch states.  They're global because they are
// owned by -- that is, only modified by -- the PDP8/pidp8i module, but
// we can't define these there because we refer to them below, and not
// all programs that link to us link to that module as well.  For such
// programs, it's fine if these two flags stay 0.
int swStop = 0, swSingInst = 0;


//// MEMORY MAPPED GPIO FUNCTIONS //////////////////////////////////////

//// map_peripheral ////////////////////////////////////////////////////
// Exposes the physical address defined in the passed structure

int map_peripheral(struct bcm2835_peripheral *p)
{
    // Open the GPIO device
    if ((p->mem_fd = open(gpio_mem_dev, O_RDWR|O_SYNC) ) < 0) {
#ifdef DEBUG
        printf("Failed to open %s: %s\n", gpio_mem_dev, strerror(errno));
        puts("Disabling PiDP-8/I front panel functionality.");
#endif
        return -1;
    }

    // Attempt to lock it.  If we can't, another program has it locked,
    // so we shouldn't keep running; it'll just end in tears.
    if (flock(p->mem_fd, LOCK_EX | LOCK_NB) < 0) {
        if (errno == EWOULDBLOCK) {
            printf("Failed to lock %s.  Only one PiDP-8/I\n", gpio_mem_dev);
            puts("program can be running at a given time.");
        }
        else {
            printf("Failed to lock %s: %s\n", gpio_mem_dev, strerror(errno));
            puts("Only one PiDP-8/I program can be running at a given time.");
        }
        return -1;
    }

    // Map the GPIO peripheral into our address space
    if ((p->map = mmap(
            NULL, BLOCK_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED,
            p->mem_fd,
            p->addr_p)) == MAP_FAILED) {
        perror("mmap");
        return -1;
    }

    // Success!
    p->addr = (volatile unsigned int *)p->map;
    pidp8i_gpio_present = 1;
    return 0;
}


//// unmap_peripheral //////////////////////////////////////////////////
// Unwind the map_peripheral() steps in reverse order

void unmap_peripheral(struct bcm2835_peripheral *p)
{
    if (pidp8i_gpio_present) {
        if (p->mem_fd > 0) {
            if (p->map) munmap(p->map, BLOCK_SIZE);
            flock(p->mem_fd, LOCK_UN);
            close(p->mem_fd);
        }
        pidp8i_gpio_present = 0;
    }
}


//// bcm_host_get_peripheral_address ///////////////////////////////////
// Find Pi's GPIO base address

unsigned bcm_host_get_peripheral_address(void)
{
    unsigned address = ~0;
    FILE *fp = fopen("/proc/device-tree/soc/ranges", "rb");
    if (fp)
    {   unsigned char buf[4];
        fseek(fp, 4, SEEK_SET);
        if (fread(buf, 1, sizeof buf, fp) == sizeof buf)
            address = buf[0] << 24 | buf[1] << 16 | buf[2] << 8 | buf[3] << 0;
        fclose(fp);
    }

    return address == ~0 ? 0x20000000 : address;
}


//// DOUBLE BUFFERED DISPLAY MANIPULATION FUNCTIONS ////////////////////

//// swap_displays ////////////////////////////////////////////////////
// Clear the current "paint-from" display, then exchange the double-
// buffered display pointers atomically, saving the current update-to
// display pointer as our paint-from display pointer and re-pointing
// the update-to pointer at the now-zeroed paint-from values.  This
// gives the CPU thread a blank slate to begin modifying while the GPIO
// thread consumes the values provided by the CPU thread.

#define SWAP(dir) \
    __atomic_exchange_n (&pdis_update, display_bufs + dir, __ATOMIC_SEQ_CST)

void swap_displays ()
{
    if (!swStop) {
        // Clear old paint-from display
        memset (pdis_paint, 0, sizeof(display));

        // Send old paint-from display to CPU as new update-to display,
        // and overwrite paint-from pointer with prior update-to pointer.
        pdis_paint = pdis_update == display_bufs + 0 ? SWAP(1) : SWAP(0);
    }
    // else, leave current LED values as-is so we don't go to a black
    // screen while in STOP mode, either from front panel or HLT
}


//// FINE GRAINED SLEEP FUNCTIONS //////////////////////////////////////

//// sleep_ns //////////////////////////////////////////////////////////
// Like sleep(2) except that it takes nanoseconds instead of seconds

void sleep_ns(ns_time_t ns)
{
    struct timespec ts = { 0, ns };
#if defined(HAVE_CLOCK_NANOSLEEP)
    clock_nanosleep(CLOCK_REALTIME, 0, &ts, NULL);
#elif defined(HAVE_NANOSLEEP)
    nanosleep(&ts, NULL);
#elif defined(HAVE_USLEEP)
    usleep(ns / 1000);
#else
#   error Cannot build GPIO controller without high-res "sleep" function!
#endif
}


//// ms_time ///////////////////////////////////////////////////////////
// Like time(2) except that it returns milliseconds since the Unix epoch

ms_time_t ms_time(ms_time_t* pt)
{
    struct timeval tv;
    if (gettimeofday(&tv, 0) == 0) {
        ms_time_t t =
                tv.tv_sec  * 1000.0 +
                tv.tv_usec / 1000.0;
        if (pt) *pt = t;
        return t;
    }
    else {
        return na_ms;
    }
}


//// SWITCH DEBOUNCING and READING FUNCTIONS ///////////////////////////

//// report_ss /////////////////////////////////////////////////////////
// Save given switch state ss into the exported switchstatus bitfield
// so the simulator core will see it.  (Constrast the gss matrix,
// which holds our internal view of the unstable truth.)

static void report_ss(int row, int col, int ss,
        struct switch_state* pss)
{
    pss->stable_state = ss;
    pss->last_change = na_ms;

    int mask = 1 << col;
    if (ss) switchstatus[row] |=  mask;
    else    switchstatus[row] &= ~mask;

    #ifdef DEBUG
        printf("%cSS[%d][%02d] = %d  ", gss_initted ? 'N' : 'I', row, col, ss);
    #endif
}


//// debounce_switch ///////////////////////////////////////////////////
// Given the state of the switch at (row,col), work out if this requires
// a change in our exported switch state.

static void debounce_switch(int row, int col, int ss, ms_time_t now_ms)
{
    struct switch_state* pss = &gss[row][col];

    if (!gss_initted) {
        // First time thru, so set this switch's module-global and
        // exported state to its defaults now that we know the switch's
        // initial state.
        report_ss(row, col, ss, pss);
    }
    else if (ss == pss->stable_state) {
        // This switch is still/again in the state we consider "stable",
        // which we are reporting in our switchstatus bitfield.  Reset
        // the debounce timer in case it is returning to its stable
        // state from a brief blip into the other state.
        pss->last_change = na_ms;
    }
    else if (pss->last_change == na_ms) {
        // This switch just left what we consider the "stable" state, so
        // start the debounce timer.
        pss->last_change = now_ms;
    }
    else if ((now_ms - pss->last_change) > debounce_ms) {
        // Switch has been in the new state long enough for the contacts
        // to have stopped bouncing: report its state change to outsiders.
        report_ss(row, col, ss, pss);
    }
    // else, switch was in the new state both this time and the one prior,
    // but it hasn't been there long enough to report it
}


//// read_switches /////////////////////////////////////////////////////
// Iterate through the switch GPIO pins, passing them to the debouncing
// mechanism above for eventual reporting to the PDP-8 CPU thread.

void read_switches (ns_time_t delay)
{
    // Save current ms-since-epoch for debouncer.  No point making it
    // retrieve this value for each switch.
    ms_time_t now_ms;
    ms_time(&now_ms);

    // Flip columns to input.  Since the internal pull-ups are enabled,
    // this pulls all switch GPIO pins high that aren't shorted to the
    // row line by the switch.
    for (size_t i = 0; i < NCOLS; ++i) {
        INP_GPIO(cols[i]);
    }

    // Read the switch rows
    for (size_t i = 0; i < NROWS; ++i) {
        // Put 0V out on the switch row so that closed switches will
        // drag its column line down; give it time to settle.
        OUT_GPIO(rows[i]);
        GPIO_CLR = 1 << rows[i];
        sleep_ns (delay);

        // Read all the switches in this row
        for (size_t j = 0; j < NCOLS; ++j) {
            int ss = GPIO_READ(cols[j]);
            debounce_switch(i, j, !!ss, now_ms);
        }

        // Stop sinking current from this row of switches
        INP_GPIO(rows[i]);
    }

    fflush(stdout);
    gss_initted = 1;
}


//// UNGROUPED FUNCTIONS ///////////////////////////////////////////////

//// pi_type ///////////////////////////////////////////////////////////
// Write a configuration string tag.

static const char* pi_type(int p)
{
    if (p == 0x20200000) {
        return "pi1+";
    }
    else {
        FILE* fp = fopen("/proc/device-tree/model", "r");
        if (fp) {
            static char ac[60];
            if (fgets(ac, sizeof(ac), fp) && (strlen(ac) > 20)) {
                if (strstr(ac, "Raspberry Pi ") == ac) {
                    int series = atoi(ac + 13);
                    char model = 'x';
                    char* pm = strstr(ac, " Model ");
                    if (pm) model = tolower(pm[7]);
                    snprintf(ac, sizeof(ac), "pi%d%c", series, model);
                    return ac;
                }
            }
            return "pi2+";
        }
    }

    return 0;       // not a Pi
}


//// update_led_states /////////////////////////////////////////////////
// Generic front panel LED updater used by NLS full time and by ILS
// while the CPU is in STOP mode.  Just uses the paint-from display's
// bitfields to turn the LEDs on full-brightness.

void update_led_states (const us_time_t delay)
{
    uint16_t *pcurr = pdis_paint->curr;
    
    // Override Execute and Run LEDs if the CPU is currently stopped,
    // since we only get set_pidp8i_leds calls while the CPU's running.
    if (swStop) {
        pdis_paint->curr[5] &= ~(1 << 2);
        pdis_paint->curr[6] &= ~(1 << 7);
    }

    for (size_t row = 0; row < NLEDROWS; ++row) {
        for (size_t col = 0; col < NCOLS; ++col) {
            if ((pcurr[row] & (1 << col)) == 0) {
                GPIO_SET = 1 << cols[col];
            }
            else {
                GPIO_CLR = 1 << cols[col];
            }
        }

        // Toggle this LED row on
        INP_GPIO (ledrows[row]);
        GPIO_SET = 1 << ledrows[row];
        OUT_GPIO (ledrows[row]);

        sleep_us (delay);

        // Toggle this LED row off
        GPIO_CLR = 1 << ledrows[row]; // superstition
        INP_GPIO (ledrows[row]);

        // Small delay to reduce UDN2981 ghosting
        sleep_us (10);
    }
}


//// gpio_thread ///////////////////////////////////////////////////////
// The GPIO thread entry point: initializes GPIO and then calls
// the gpio_core () implementation linked to this program.

void *gpio_thread (void *terminate)
{
    // Find GPIO address (it varies by Pi model)
    gpio.addr_p = bcm_host_get_peripheral_address() + 0x200000;

    // Set thread to real time priority
    struct sched_param sp;
    sp.sched_priority = 4;  // not high, just above the minimum of 1
    int rt = pthread_setschedparam(pthread_self(), SCHED_FIFO, &sp) == 0;

    // Map the GPIO peripheral, but hold off exiting if it fails, until
    // we report its absence in the config line.
    int mapped = map_peripheral(&gpio) == 0;

    // Tell the user about our configuration, succinctly
    const char* pt = pi_type(mapped ? gpio.addr_p : 0);
    printf(
        "PiDP-8/I @VERSION@ [%s] [@LED_DRIVER_MODULE@ls] [%spcb]%s"
#ifdef DEBUG
        " [debug]"
#endif
        "%s",
        pt ? pt : "cake",       // pt == 0 == not a Pi
        pt ? 
#ifdef PCB_SERIAL_MOD
            "ser" : 
#else
            "std" : 
#endif
            "no",
        mapped ? " [gpio]" : "",
        rt     ? " [rt]" : ""
    );

    // If we didn't map the GPIO peripheral, we've done all we can here
    if (!mapped) return (void*)-1;

    // Until gpio_core () reads the switches for the first time, we need
    // to mark them as all-open, lest we have a race condition with the
    // simulator where it interprets the all-0 initial switchstatus[]
    // value as "all switches closed," which includes the shutdown seq!
    memset(switchstatus, 0xFF, sizeof(switchstatus));

    // initialise GPIO (all pins used as inputs, with pull-ups enabled on cols)
    //  INSERT CODE HERE TO SET GPIO 14 AND 15 TO I/O INSTEAD OF ALT 0.
    //  AT THE MOMENT, USE "sudo ./gpio mode 14 in" and "sudo ./gpio mode 15 in". "sudo ./gpio readall" to verify.
    #define pgpio (&gpio)
    int i;
    for (i = 0; i < NLEDROWS; i++) {     // Define ledrows as input
        INP_GPIO(ledrows[i]);
        GPIO_CLR = 1 << ledrows[i];     // so go to Low when switched to output
    }
    for (i = 0; i < NCOLS; i++) {       // Define cols as input
        INP_GPIO(cols[i]);
    }
    for (i = 0; i < NROWS; i++) {       // Define rows as input
        INP_GPIO(rows[i]);
    }

    // BCM2835 ARM Peripherals PDF p 101 & elinux.org/RPi_Low-level_peripherals#Internal_Pull-Ups_.26_Pull-Downs
    GPIO_PULL = 2;  // pull-up
    usleep(1);  // must wait 150 cycles
#ifdef PCB_SERIAL_MOD
    GPIO_PULLCLK0 = 0x03ffc; // selects GPIO pins 2..13 (frees up serial port on 14 & 15)
#else
    GPIO_PULLCLK0 = 0x0fff0; // selects GPIO pins 4..15 (assumes we avoid pins 2 and 3!)
#endif
    usleep(1);
    GPIO_PULL = 0; // reset GPPUD register
    usleep(1);
    GPIO_PULLCLK0 = 0; // remove clock
    usleep(1); // probably unnecessary

    // BCM2835 ARM Peripherals PDF p 101 & elinux.org/RPi_Low-level_peripherals#Internal_Pull-Ups_.26_Pull-Downs
    GPIO_PULL = 1;  // pull-down to avoid ghosting (dec2015)
    usleep(1);  // must wait 150 cycles
    GPIO_PULLCLK0 = 0x0ff00000; // selects GPIO pins 20..27
    usleep(1);
    GPIO_PULL = 0; // reset GPPUD register
    usleep(1);
    GPIO_PULLCLK0 = 0; // remove clock
    usleep(1); // probably unnecessary

    // BCM2835 ARM Peripherals PDF p 101 & elinux.org/RPi_Low-level_peripherals#Internal_Pull-Ups_.26_Pull-Downs
    GPIO_PULL = 0;  // no pull-up no pull down just float
    usleep(1);  // must wait 150 cycles
    GPIO_PULLCLK0 = 0x070000; // selects GPIO pins 16..18
    usleep(1);
    GPIO_PULL = 0; // reset GPPUD register
    usleep(1);
    GPIO_PULLCLK0 = 0; // remove clock
    usleep(1); // probably unnecessary

    // Hand off control to the gpio_core () variant linked to this
    // program: either the new incandescent lamp simulator or the old
    // stock version.
    extern void gpio_core (struct bcm2835_peripheral*, int* terminate);
    gpio_core (&gpio, (int*)terminate);

    // gpio_core () leaves all cols, rows, ledrows are set to input, and
    // it's safe to leave them in that state.  No need to de-init GPIO.
    gss_initted = 0;
    return 0;
}
